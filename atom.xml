<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[VALUX]]></title>
  <subtitle><![CDATA[Coding the world.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://valux.cn//"/>
  <updated>2015-10-12T13:33:16.324Z</updated>
  <id>http://valux.cn//</id>
  
  <author>
    <name><![CDATA[VALUX]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[UML类图学习总结]]></title>
    <link href="http://valux.cn/2015/09/24/f4de94c4e38297da/"/>
    <id>http://valux.cn/2015/09/24/f4de94c4e38297da/</id>
    <published>2015-09-23T16:24:32.000Z</published>
    <updated>2015-10-12T13:33:16.324Z</updated>
    <content type="html"><![CDATA[<h3 id="UML类图">UML类图</h3><p>UML类图中，通常用如下图示表示一个类（接口），将成员变量和方法依次列出，同时可以用<code>+/-</code>作为访问控制符标识其在类里的访问范围<br><img src="/img/20150924/20150924-01.png" alt="UML类图"><br>通常，类（接口）之间有如下六种关系</p>
<blockquote>
<ol>
<li>泛化 - <em>Generalization</em></li>
<li>实现 - <em>Realization</em></li>
<li>组合 - <em>Composition</em></li>
<li>聚合 - <em>Aggregation</em></li>
<li>关联 - <em>Association</em></li>
<li>依赖 - <em>Dependency</em></li>
</ol>
</blockquote>
<p><code>关联</code>、<code>聚合</code>、<code>组合</code>、<code>依赖</code>在其形态上比较接近，但是可以通过类之间关系的强弱来区分，具体如下</p>
<blockquote>
<p>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 </p>
</blockquote>
<h3 id="1-_泛化_Generalization">1. 泛化 Generalization</h3><p><code>泛化</code>描述的是一种高度抽象的继承关系，从一般到特殊，从父类继承所有属性和行为到子类并扩展。通常用空心三角箭头实线表示<code>泛化</code>关系，箭头指向父类<br><img src="/img/20150924/20150924-02.png" alt="泛化"><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Human</span>: <span class="title">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Animal</code>是一个泛化的类，而且动物本身是一个抽象的概念，因此可以标记为<code>抽象类</code>。同时我们从抽象的<code>Animal</code>特化出其子类<code>Human</code>，继承了其所有的属性，同时可以扩展出特化的方法或者特性，例如<code>speak</code>。这里可以根据<code>OOP</code>思想，将<code>泛化</code>理解为<code>is-a</code>。</p>
<h3 id="2-_实现_Realization">2. 实现 Realization</h3><p><code>实现</code>描述的是类和接口的关系，表示类对接口所定义的特性和行为的实现。通常用空心三角箭头虚线表示<code>实现</code>关系，箭头指向接口<br><img src="/img/20150924/20150924-03.png" alt="实现"><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMoveable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bird</span>: <span class="title">IMoveable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Move</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>实现</code>通过<code>接口</code>规范行为，不同的子类需要实现相同的行为，但是可以表现为不同的形式。</p>
<h3 id="3-_组合_Composition">3. 组合 Composition</h3><p><code>组合</code>描述的也是整体与部分之间的关系，但是部分不能脱离整体单独用存在。通常用实心菱形实线表示，菱形指向整体<br><img src="/img/20150924/20150924-06.png" alt="组合"><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Department</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Company</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Department&gt; Departments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Department</code>这里也是一个抽象并不实际存在的概念，需要依赖于<code>Company</code>这个整体，同时也<em>组成</em>了<code>Company</code>这个整体</p>
<h3 id="4-_聚合_Aggregation">4. 聚合 Aggregation</h3><p><code>聚合</code>描述的是整体与部分之间的关系，但是部分可以脱离整体单独存在。通常用空心菱形实线表示，菱形指向整体<br><img src="/img/20150924/20150924-05.png" alt="聚合"><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CPU</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Memery</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CPU Cpu &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Memery Memery &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>聚合</code>和<code>组合</code>概念感觉非常相近，但是可以看出<code>CPU</code>和<code>Memery</code>这两个部分是可以独立于<code>Computer</code>这个整体而存在的</p>
<h3 id="5-_关联_Association">5. 关联 Association</h3><p><code>关联</code>描述的是类与类之间的联接关系，即一个类知道另一个类的属性和方法，这种关系既可以是单项的，也可以使双向的。通常用箭头实线表示<br><img src="/img/20150924/20150924-04.png" alt="关联"><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Course</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Course&gt; Courses &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; Teachers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Course&gt; Courses &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-_依赖_Dependency">6. 依赖 Dependency</h3><p><code>依赖</code>描述的是使用关系，即一个类完成某种功能或者特性需要另外一个类的协助，而且这种依赖一般是单向的。通常使用单箭头的虚线表示，箭头指向依赖方<br><img src="/img/20150924/20150924-07.png" alt="组合"><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Computer</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoWork</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Engineer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Computer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engineer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Computer = <span class="keyword">new</span> Computer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Engineer</code>依赖于<code>Computer</code>完成工作，这种关系是单向的</p>
<h3 id="参考">参考</h3><blockquote>
<p><a href="http://blog.csdn.net/xhf55555/article/details/6896316/" target="_blank" rel="external">UML类图实例</a><br><a href="http://www.open-open.com/lib/view/open1328059700311.html" target="_blank" rel="external">UML类图几种关系的总结</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="UML类图">UML类图</h3><p>UML类图中，通常用如下图示表示一个类（接口），将成员变量和方法依次列出，同时可以用<code>+/-</code>作为访问控制符标识其在类里的访问范围<br><img src="/img/20150924/20150924]]>
    </summary>
    
      <category term="UML" scheme="http://valux.cn/tags/UML/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="other" scheme="http://valux.cn/categories/essay/other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的this关键字]]></title>
    <link href="http://valux.cn/2015/09/23/0140f67a4e72fb49/"/>
    <id>http://valux.cn/2015/09/23/0140f67a4e72fb49/</id>
    <published>2015-09-23T02:24:32.000Z</published>
    <updated>2015-10-07T09:47:21.128Z</updated>
    <content type="html"><![CDATA[<h3 id="this_关键字">this 关键字</h3><p><code>this</code>关键字在<code>javascript</code>中比较微妙，通常<code>this</code>指向函数<em>执行时</em>的当前对象。如果没有明确当前对象，那么<code>this</code>指向的是一个<em>全局对象</em>，在浏览器中，这个<em>全局对象</em>就是<code>window</code> </p>
<h3 id="0-_问题">0. 问题</h3><p>这也是最近面试前端时出的一道题，正确率比较低<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">"World"</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    waitSayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    fooSayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;,</span><br><span class="line">    evalSayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">"console.log('Hello '+ this.name)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) o.sayHello();        </span><br><span class="line"><span class="number">2</span>) o.waitSayHello();    </span><br><span class="line"><span class="number">3</span>) o.fooSayHello();     </span><br><span class="line"><span class="number">4</span>) o.evalSayHello();</span><br></pre></td></tr></table></figure></p>
<h3 id="1-_Q1">1. Q1</h3><blockquote>
<p>Hello World   </p>
</blockquote>
<p>送分题，这里我们首先定义了全局变量<code>name</code>，然后定义了对象<code>o</code>，默认情况下<code>o</code>中的<code>this</code>关键字都应该指代对象<code>o</code></p>
<h3 id="2-_Q2">2. Q2</h3><blockquote>
<p>Hello Javascript</p>
</blockquote>
<p><code>setTimeout</code> 和 <code>setInterval</code>在执行时，当前对象指代的是全局对象。为了保证在匿名回调函数里进行正确的指代，我们对代码做如下修改<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">"World"</span>,</span><br><span class="line">    waitSayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + self.name);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure></p>
<p>根据闭包的特性利用<code>self</code>指向当前的对象</p>
<h3 id="3-_Q3">3. Q3</h3><blockquote>
<p>Hello Javascript</p>
</blockquote>
<p>这里直接返回了一个自执行的匿名函数，注意，此匿名函数<code>return</code>后的作用域已经跳出的对象<code>o</code>，运行时此匿名函数中的<code>this</code>指代的便是全局对象。为了便于理解继续看如下代码，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = o.sayHello</span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Hello Javascript</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们将<code>sayHello</code>这个函数传递给<code>foo</code>，并单独执行。注意其运行时已经处于了全局对象中。这里和<code>call</code>，<code>apply</code>原理类似，已经强制改变了函数执行时的当前对象</p>
<h3 id="4-_Q4">4. Q4</h3><blockquote>
<p>Hello World</p>
</blockquote>
<p><code>eval</code>执行代码的作用域依然处于当前作用域内</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="this_关键字">this 关键字</h3><p><code>this</code>关键字在<code>javascript</code>中比较微妙，通常<code>this</code>指向函数<em>执行时</em>的当前对象。如果没有明确当前对象，那么<c]]>
    </summary>
    
      <category term="Javascript" scheme="http://valux.cn/tags/Javascript/"/>
    
      <category term="this" scheme="http://valux.cn/tags/this/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="javascript" scheme="http://valux.cn/categories/essay/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hive导出数据到集群问题]]></title>
    <link href="http://valux.cn/2015/09/20/42a86dc34527798d/"/>
    <id>http://valux.cn/2015/09/20/42a86dc34527798d/</id>
    <published>2015-09-20T02:21:25.000Z</published>
    <updated>2015-09-24T16:25:33.461Z</updated>
    <content type="html"><![CDATA[<p>使用<code>hive</code>过程导出数据命令如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> OVERWRITE [<span class="keyword">LOCAL</span>] DIRECTORY <span class="string">'path'</span> </span><br><span class="line"><span class="keyword">SELECT</span> ...</span></span><br></pre></td></tr></table></figure></p>
<p>如果添加了<code>LOCAL</code>关键字，则会在本地及路径导出数据，否则导出到集群地址。</p>
<blockquote>
<p>使用过程中发现一个问题，每次导出到<code>集群地址</code>时，最后一步总是<code>distcp</code>操作，耗时很长。<br>原来<code>HIVE</code>执行过程中会在临时地址导出数据，再进行一次复制  </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用<code>hive</code>过程导出数据命令如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span cl]]>
    </summary>
    
      <category term="hive" scheme="http://valux.cn/tags/hive/"/>
    
      <category term="eassy" scheme="http://valux.cn/categories/eassy/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/eassy/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一道前端笔试题add(2)(6)]]></title>
    <link href="http://valux.cn/2015/09/11/e69dc94caee129a6/"/>
    <id>http://valux.cn/2015/09/11/e69dc94caee129a6/</id>
    <published>2015-09-10T16:24:32.000Z</published>
    <updated>2015-10-07T09:57:02.051Z</updated>
    <content type="html"><![CDATA[<h3 id="题目">题目</h3><p>最近面前端，出了如下一道题</p>
<blockquote>
<p>实现以下函数<br>1) add(2, 6)  // 8<br>2) add(2)(6)  // 8   请考虑兼容如下调用 add(1)(3)(5)(7)(9)</p>
</blockquote>
<p>第1)问没什么难度，第2)问目前为止没人答得很好。<br>咋一看题目很简单，其实不然。一般童鞋第2)问只能写出如下</p>
<h3 id="答案1">答案1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>)(<span class="number">6</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>两层调用时很简单，只需返回一个函数，构建闭包暂存<code>x</code>的值，但是要实现后面无限级的函数链式调用，几乎没有人答对</p>
<h3 id="答案2">答案2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> total = x; </span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; </span><br><span class="line">        total = total + y; </span><br><span class="line">        <span class="keyword">return</span> f; </span><br><span class="line">    &#125;	</span><br><span class="line">    f.toString = f.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要考的还是<code>闭包</code>的应用</p>
<blockquote>
<ol>
<li>首先需要<code>total</code>这个闭包变量暂存每次累加的值  </li>
<li>要实现多级函数链式调用，同样需要返回一个函数<code>f</code>,并在这个函数内实现累加</li>
<li>由于返回的是函数<code>f</code>，那么在执行<code>+</code>运算时，默认会调用<code>valueOf</code>，因此我们需要Overwrite这个方法</li>
<li>同时，使用<code>console.log()</code>时会调用<code>toString</code>方法，因此也一并Overwrite了</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目">题目</h3><p>最近面前端，出了如下一道题</p>
<blockquote>
<p>实现以下函数<br>1) add(2, 6)  // 8<br>2) add(2)(6)  // 8   请考虑兼容如下调用 add(1)(3)(5)(7)(9)</p]]>
    </summary>
    
      <category term="javascript" scheme="http://valux.cn/tags/javascript/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="javascript" scheme="http://valux.cn/categories/essay/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[七月再见]]></title>
    <link href="http://valux.cn/2015/07/31/86c5ab2f5ec12c92/"/>
    <id>http://valux.cn/2015/07/31/86c5ab2f5ec12c92/</id>
    <published>2015-07-30T17:46:50.000Z</published>
    <updated>2015-08-02T19:22:53.859Z</updated>
    <content type="html"><![CDATA[<p>跳槽完第一个月过得很快。 </p>
<h3 id="离职">离职</h3><p>实在忍受不了以前慢条斯理的开发节奏，四个人做一个人可以完成的事，至始至终都在破烂不堪的系统上打着补丁。每次提重构或者新架构，总是以老大不愿冒险而告终。于是，月初选择了离职。</p>
<h3 id="新公司">新公司</h3><p>在几个<code>Offer</code>中挑了现在的创业公司，虽然给的待遇不是最好，感觉可能会更有发展的空间，可以认识更多的牛人。不巧的是一来就被安排完成大数据相关任务，虽然有相关经验，但是都用的是<code>python</code>，现有的程序都是<code>java</code>。</p>
<p>问题倒是不大，一个星期基本都接手过来，把原来写得乱七八糟的代码全部重构了，    也学了一些集群优化相关的内容，本身两三天可以跑完的任务基本优化到了个10个时。整个流程也全部串起来做了自动化的运维。</p>
<h3 id="新工作">新工作</h3><p>当然，中间还是出了一些问题，之前集群响应太慢，测试耗时太长，加上业务不太熟也导致了整个流程的推迟，终于还是赶在<code>DEADLINE</code>之前完成了我的任务。可是，最终，小伙伴在导入数据的时候出了问题，导致整个流程的数据都不可信。无可奈何，本着负责的态度，我默默的发邮件背了锅，毕竟我最后没有按时提供数据。</p>
<p>然后，新需求里小伙伴一个简单的修改，又导致数据缺失，虽然这次不太严重。但是背锅的总是我，除了责任，其它的总是与我无关。</p>
<p>月末，我才发现，原来我这一个月做的事情在公司看来，好像都与我无关。倒不是在乎任何外在的东西，而你的努力，不但没被认可，还成了别人的嫁衣，多少还是有点失落。</p>
<p>我总是闲不住要做持续优化和改进，在项目的不同阶段总会有更好的方式或者方法，至少我觉得是更好。提了一部分优化方案，最终还是被踢皮球踢的不了了之，其实根本原因还是能力不被认可。</p>
<p>公司在疯狂扩张，招得人感觉也鱼龙混杂。我是个技术控，虽然不是大神，但特别排斥那种在技术上瞎侃的童鞋。由于自身不是很自信，你认真的跟我瞎侃一会我可能就信了，但是终究我还是会去查资料的。想起之前著名<code>面霸</code>公司的两个童鞋了，一唱一和把我忽悠的一愣一愣的，面完我认真看了看资料，只想说句<code>呵呵</code>。</p>
<h3 id="七月再见">七月再见</h3><p>负面的事情想多了，整个人就阴暗了，毕竟这些都已经成过去时了，那么，七月再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>跳槽完第一个月过得很快。 </p>
<h3 id="离职">离职</h3><p>实在忍受不了以前慢条斯理的开发节奏，四个人做一个人可以完成的事，至始至终都在破烂不堪的系统上打着补丁。每次提重构或者新架构，总是以老大不愿冒险而告终。于是，月初选择了离职。</p>
<h3 id]]>
    </summary>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="other" scheme="http://valux.cn/categories/essay/other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MapReduce 进行 HBase 导库]]></title>
    <link href="http://valux.cn/2015/07/12/9544d87a62b2c59b/"/>
    <id>http://valux.cn/2015/07/12/9544d87a62b2c59b/</id>
    <published>2015-07-12T03:02:51.000Z</published>
    <updated>2015-07-31T19:45:22.221Z</updated>
    <content type="html"><![CDATA[<h3 id="HBase_导出数据方式">HBase 导出数据方式</h3><p>作为零基础java选手，刚来公司要就要写 map - reduce 从HBase导大量数。好在已经有个现成能跑的程序，大致浏览了下，虽然写得有点乱，不过不影响理解，毕竟第一次写 map - reduce 压力还是有点大。目前的需求是从 <code>HBase</code> 导出到 <code>HBase</code>，大致分两种方式</p>
<blockquote>
<ol>
<li>HBase -&gt; HBase 适合数据量较小的情况，导入速度相对较慢 </li>
<li>HBase -&gt; HFile -&gt; HBase 推荐的bulk loading 方式，先将数据导出成<code>HFile</code>，然后再从<code>HFile</code>加载到HBase里    </li>
</ol>
</blockquote>
<h3 id="Mapper">Mapper</h3><p>不论采用哪种方式，首先都必须要实现一个 mapper，<code>HBase</code>也提供了一个封装好的抽象类<code>TableMapper</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TableMapper</span>&lt;<span class="title">KEYOUT</span>, <span class="title">VALUEOUT</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">ImmutableBytesWritable</span>, <span class="title">Result</span>, <span class="title">KEYOUT</span>, <span class="title">VALUEOUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>TableMapper</code>继承自<code>Mapper</code>，封装了其输入的<code>KEYIN</code>和<code>KEYOUT</code>，因为HBase每行记录都会被映射为一个<code>ImmutableBytesWritable</code>和<code>Result</code>，因此重写<code>map</code>函数时，其输入只能是<code>ImmutableBytesWritable</code>和<code>Result</code>。</p>
<blockquote>
<p>需求1. 假设我们现在有个统计开源项目的HBase表，假设我们的需求是导出所有<code>name</code>字段包含<code>hadoop</code>字符串的记录</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.<span class="type">ImmutableBytesWritable</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.<span class="type">TableMapper</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.<span class="type">Bytes</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">IOException</span>;</span><br><span class="line"></span><br><span class="line">public class <span class="type">ExampleMapper</span> extends <span class="type">TableMapper</span>&lt;<span class="type">ImmutableBytesWritable</span>, <span class="type">Result</span>&gt; &#123;</span><br><span class="line">    public <span class="type">void</span> map(<span class="type">ImmutableBytesWritable</span> row, <span class="type">Result</span> <span class="literal">result</span>,</span><br><span class="line">                    <span class="type">Context</span> context) throws <span class="type">InterruptedException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">String</span> name = <span class="type">Bytes</span>.toString(<span class="literal">result</span>.getValue(<span class="type">Bytes</span>.toBytes(<span class="string">"f1"</span>), <span class="type">Bytes</span>.toBytes(<span class="string">"name"</span>)));</span><br><span class="line">        <span class="keyword">if</span> (name.indexOf(<span class="string">"hadoop"</span>) &lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        context.write(row, <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时,<code>map</code>过程的输出是可以任意改变的，但是KEYOUT和VALUEOUT必须都实现了<code>Writable</code>这个接口，因为map的数据后续可能被洗牌，需要能够被序列化。</p>
<blockquote>
<p>需求2. 例如此时我们的需求还需要排重（统计分类），依照<code>language</code>字段对所有项目归类，那么<code>map</code>方法可以修改为</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleMapper</span> <span class="keyword">extends</span> <span class="title">TableMapper</span>&lt;<span class="title">ImmutableBytesWritable</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(ImmutableBytesWritable row, Result result,</span><br><span class="line">                    Context context)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">        String name = Bytes.toString(result.getValue(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>)));</span><br><span class="line">        <span class="keyword">if</span> (name.indexOf(<span class="string">"hadoop"</span>) &lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        String language = Bytes.toString(result.getValue(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"language"</span>)));</span><br><span class="line">        context.write(<span class="keyword">new</span> ImmutableBytesWritable(language.getBytes()), result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>combiner</code>和<code>reducer</code>阶段便可以通过这个KEY进行聚合</p>
<h3 id="Reducer">Reducer</h3><p><code>Reducer</code>在某些情况下是可以<code>省略</code>的，但是因为这里要排重，所以在这个需求是必须的<br><code>HBase</code>同样对<code>Reducer</code>进行了一层封装，提供了一个抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TableReducer</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>, <span class="title">KEYOUT</span>&gt; <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>, <span class="title">KEYOUT</span>, <span class="title">Mutation</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableReducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么<code>reducer</code>类可以根据需求写作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Result;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReducer</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">ImmutableBytesWritable</span>,<span class="title">Result</span>,<span class="title">ImmutableBytesWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(ImmutableBytesWritable row, <span class="keyword">final</span> Iterable&lt;Result&gt; values,</span><br><span class="line">                       Context context)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Result&gt; iters = values.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        Put put = <span class="keyword">new</span> Put(row.get());</span><br><span class="line">        <span class="keyword">while</span> (iters.hasNext()) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">            Result it = iters.next();            </span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">        put.add(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"counter"</span>), Bytes.toBytes(counter));</span><br><span class="line">        <span class="comment">// 其它业务逻辑</span></span><br><span class="line">        context.write(row, put);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reducer</code>的VALUEIN是一个迭代器，包含了同一个KEY的所有值，因此我们可以遍历它进行相关聚合运算或者其它业务逻辑。例如，这里统计了每种<code>language</code>包含项目的数量</p>
<h3 id="HBase_普通导入方式">HBase 普通导入方式</h3><p><code>HBase</code> 同样针对MPR提供了简洁的封装类<code>TableMapReduceUtil</code>，常用的重载可以表示为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTableMapperJob</span><span class="params">(String table, Scan scan, Class&lt;? extends TableMapper&gt; mapper, Class&lt;?&gt; outputKeyClass, Class&lt;?&gt; outputValueClass, Job job)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTableReducerJob</span><span class="params">(String table, Class&lt;? extends TableReducer&gt; reducer, Job job)</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么<code>driver</code>程序端可以表示为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Scan;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, Confs.HBASE_ZOOKEEPER_QUORUM);</span><br><span class="line">        Commons.hbaseCreateTable(conf, targetTableName);</span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf, Confs.JOB_NAME);</span><br><span class="line">        job.setJarByClass(ExampleExporter.class);</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        scan.addFamily(Bytes.toBytes(Confs.HBASE_COLUMN_FAMILY_F1));</span><br><span class="line">        TableMapReduceUtil.initTableMapperJob(sourceTableName, scan, ExampleMapper.class,</span><br><span class="line">                ImmutableBytesWritable.class, Put.class, job);</span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(targetTableName, <span class="keyword">null</span>, job);</span><br><span class="line">        <span class="comment">//TableMapReduceUtil.initTableReducerJob(targetTableName, ExampleReducer.class, job);</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在设置<code>initTableReducerJob</code>可根据具体情况设置<code>reducer</code>，如果没有设置具体的<code>reducer</code>，那么<code>map</code>阶段结束后，会直接写入到<code>targetTableName</code></p>
<h3 id="HBase_Bulk_Loading">HBase Bulk Loading</h3><p>普通导入方式非常灵活，但缺点就是导入大量数据时，速度较慢。因此<code>HBase</code>还提供了<code>Bulk Loading</code>的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, Confs.HBASE_ZOOKEEPER_QUORUM);</span><br><span class="line">        Commons.hbaseCreateTable(conf, targetTableName);</span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf, Confs.JOB_NAME);</span><br><span class="line">        job.setJarByClass(ExampleExporter.class);</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        scan.addFamily(Bytes.toBytes(Confs.HBASE_COLUMN_FAMILY_F1));</span><br><span class="line">        TableMapReduceUtil.initTableMapperJob(sourceTableName, scan, ExampleMapper.class,</span><br><span class="line">                ImmutableBytesWritable.class, Put.class, job);</span><br><span class="line">        </span><br><span class="line">        HTable hTable = <span class="keyword">new</span> HTable(conf, targetTableName);</span><br><span class="line">        job.setReducerClass(PutSortReducer.class);        </span><br><span class="line">        Path outputDir = <span class="keyword">new</span> Path(hfilePath);        </span><br><span class="line">        FileOutputFormat.setOutputPath(job, outputDir);</span><br><span class="line">        job.setMapOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">        job.setMapOutputValueClass(Put.class);</span><br><span class="line">        HFileOutputFormat.configureIncrementalLoad(job, hTable);</span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        LoadIncrementalHFiles loader = <span class="keyword">new</span> LoadIncrementalHFiles(conf);</span><br><span class="line">        loader.doBulkLoad(outputDir, hTable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bulk Loading</code>方式会先写入<code>HFile</code>，然后再从<code>HFile</code>加载到HBase里，导出效率会高出很多，但是也有限制</p>
<blockquote>
<p>输出的<code>HFile</code>必须<strong>有序</strong>，因此一般会默认使用<code>PutSortReducer</code>，如果需要做聚合操作还需要在自己的<code>reducer</code>里对结果按照<code>KEY</code>进行排序，具体可以参考下<code>PutSortReducer</code>的实现</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="HBase_导出数据方式">HBase 导出数据方式</h3><p>作为零基础java选手，刚来公司要就要写 map - reduce 从HBase导大量数。好在已经有个现成能跑的程序，大致浏览了下，虽然写得有点乱，不过不影响理解，毕竟第一次写 map - red]]>
    </summary>
    
      <category term="hbase" scheme="http://valux.cn/tags/hbase/"/>
    
      <category term="mapreduce" scheme="http://valux.cn/tags/mapreduce/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/essay/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高性能IO模型浅析]]></title>
    <link href="http://valux.cn/2015/06/02/13462a894cbd366e/"/>
    <id>http://valux.cn/2015/06/02/13462a894cbd366e/</id>
    <published>2015-06-01T16:04:31.000Z</published>
    <updated>2015-07-31T19:48:20.937Z</updated>
    <content type="html"><![CDATA[<p style="margin: 0pt auto;"><span style="text-align: right;"><br></span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">（1）</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">同步阻塞IO（Blocking IO）：即传统的IO模型。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">（2）</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">同步非阻塞</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">（3）</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">（4）</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto 0pt 21pt; text-indent: 10pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; color: rgb(255, 0, 0); font-family: 宋体; font-size: 10.5pt; font-weight: bold;">同步和异步</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; color: rgb(255, 0, 0); font-family: 宋体; font-size: 10.5pt; font-weight: bold;">阻塞和非阻塞</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto 0pt 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">另外，</span><span style="line-height: 1.8; font-family: 'Times New Roman'; font-size: 10.5pt;">Richard Stevens</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;"> 在《Unix 网络编程》卷1中提到的基于信号驱动的IO（Signal Driven IO）模型，由于该模型并不常用，本文不作涉及。接下来，我们详细分析四种常见的IO模型的实现原理。为了方便描述，我们统一使用IO的读操作作为示例。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(102, 204, 255);"><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">一、</span><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">同步阻塞IO</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><img alt="" src="http://images.cnitblog.com/blog/405877/201411/142330286789443.png" width="535" height="285" style="width: 535px; height: 285px;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">1 同步阻塞IO</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图1所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户线程使用同步阻塞IO模型的伪代码描述为：</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">{</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">read(socket, buffer)</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">;</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">process(buffer)</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">;</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(102, 204, 255);"><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">二、</span><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">同步非阻塞IO</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。</span></p><p style="line-height: 25.2000007629395px; margin-top: 10px; margin-right: auto; margin-left: auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"> <img alt="" src="http://images.cnitblog.com/blog/405877/201411/142332004602984.png" width="562" height="315" style="width: 562.5px; height: 315.28px; line-height: 1.5;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图2 同步非阻塞IO</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图2所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户线程使用同步非阻塞IO模型的伪代码描述为：</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">{</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">while(</span><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">read(socket, buffer)</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;"> != SUCCESS)</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">;</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">process(buffer)</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">;</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(102, 204, 255);"><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">三、</span><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">IO多路复用</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><img alt="" src="http://images.cnitblog.com/blog/405877/201411/142332187256396.png" width="539" height="320" style="width: 539.49px; height: 320.7px;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图3 多路分离函数select</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图3所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在</span><span style="line-height: 1.8; color: rgb(255, 0, 0); font-family: 宋体; font-size: 10.5pt; font-weight: bold;">同一个线程内同时处理多个IO请求的目的</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户线程使用select函数的伪代码描述为：</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">{</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">select(socket);</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">while(1) </span><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">{</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">sockets = select();</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">for(socket in sockets) {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 84pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">if(can_read(socket)) {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 105pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">read(socket, buffer);</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 105pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">process(buffer)</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">;</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 84pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 'Courier New'; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">然而，使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">IO多路复用模型使用了Reactor设计模式实现了这一机制。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><img alt="" src="http://images.cnitblog.com/blog/405877/201411/142332350853195.png" width="567" height="185" style="width: 567px; height: 185px;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图4 Reactor设计模式</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图4所示，EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><img alt="" src="http://images.cnitblog.com/blog/405877/201411/142333254136604.png" width="647" height="300" style="width: 647.32px; height: 300.84px;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">5 IO多路复用</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图5所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户线程使用IO多路复用模型的伪代码描述为：</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">void UserEventHandler::handle_event() {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">if(can_read(socket)) {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">read(socket, buffer);</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">process(buffer);</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">{</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">Reactor.register(new UserEventHandler(socket));</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">Reactor::handle_events() {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">while(1) {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">sockets = select();</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">for(socket in sockets) {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 84pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">get_event_handler(socket).handle_event();</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(102, 204, 255);"><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">四、</span><span style="line-height: 1.8; font-family: 宋体; font-size: 14pt; font-weight: bold;">异步IO</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">异步IO模型使用了Proactor设计模式实现了这一机制。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><img alt="" src="http://images.cnitblog.com/blog/405877/201411/151608309061672.jpg" width="744" height="248" style="width: 744.12px; height: 248.62px;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图6 Proactor设计模式</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图6，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><img alt="" src="http://images.cnitblog.com/blog/405877/201411/142333511475767.png" width="686" height="297" style="width: 686.63px; height: 297.72px;"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: center;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">图</span><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">7 异步IO</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">如图7所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户线程使用异步IO模型的伪代码描述为：</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">void UserCompletionHandler::handle_event(buffer) {</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 63pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">process(buffer);</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">{</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 42pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">aio_read(socket, new UserCompletionHandler);</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify; background: rgb(230, 230, 230);"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">}</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px; text-align: justify;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; text-indent: 21pt; color: rgb(51, 51, 51); font-family: 微软雅黑; font-size: 14px;"><span style="line-height: 1.8; font-family: 宋体; font-size: 10.5pt;">本文从基本概念、工作流程和代码示例三个层次简要描述了常见的四种高性能IO模型的结构和原理，理清了同步、异步、阻塞、非阻塞这些容易混淆的概念。通过对高性能IO模型的理解，可以在服务端程序的开发中选择更符合实际业务特点的IO模型，提高服务质量。希望本文对你有所帮助。</span></p>

<h3 id="参考文档">参考文档</h3><blockquote>
<p>作者：Florian<br>原文：<a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html" target="_blank" rel="external">http://www.cnblogs.com/fanzhidongyzby/p/4098546.html</a>    </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p style="margin: 0pt auto;"><span style="text-align: right;"><br></span></p><p style="line-height: 25.2000007629395px; margin: 0pt auto; te]]>
    </summary>
    
      <category term="io" scheme="http://valux.cn/tags/io/"/>
    
      <category term="异步" scheme="http://valux.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="share" scheme="http://valux.cn/categories/share/"/>
    
      <category term="other" scheme="http://valux.cn/categories/share/other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PySpark调用自定义jar包]]></title>
    <link href="http://valux.cn/2015/05/16/72eca5e737523eae/"/>
    <id>http://valux.cn/2015/05/16/72eca5e737523eae/</id>
    <published>2015-05-15T16:04:31.000Z</published>
    <updated>2015-07-31T19:48:40.030Z</updated>
    <content type="html"><![CDATA[<p>在开发<code>PySpark</code>程序时通常会需要用到Java的对象，而<code>PySpark</code>本身也是建立在Java API之上，通过Py4j来创建<code>JavaSparkContext</code>。</p>
<p><img src="/img/20150516103730983.jpg" alt="Cached / shuffled" title="Cached / shuffled"></p>
<p>这里有几点是需要注意的</p>
<h4 id="1-_Py4j只运行在driver">1. Py4j只运行在driver</h4><p>也就是说<code>worker</code>目前来说引入不了第三方的jar包。因为<code>worker</code>结点的PySpark是没有启动Py4j的通信进程的，相应的jar包自然也加载不了。之前没有详细看这部分文档，系统设计时企图在<code>worker</code>结点利用client模式直连Hbase来获取部分数据，从而避免对整个表的JOIN操作，当然对于python来说这样的操作只有通过引入jar包来实现(不考虑thrift方式)。但是测试的jar写好之后，一直不成功，最后只有修改方案，后来才去查了官方文档。</p>
<h4 id="2-_PythonRDD_的原型是_JavaRDD[String]">2. PythonRDD 的原型是 JavaRDD[String]</h4><p>所有的经过PythonRDD传递的数据都通过BASE64编码</p>
<h4 id="3-_PySpark_中的方法和匿名函数是通过cloudpickle序列化">3. PySpark 中的方法和匿名函数是通过cloudpickle序列化</h4><p>为何函数需要被序列化，因为做<code>map</code>或者<code>flatMap</code>时，此时的函数或者lambda表达式是需要传递到各个<code>worder</code>的，如果函数里有用到闭包，<code>cloudpickle</code>也能巧妙的序列化。但是，需要传递的函数里请不要是用<code>self</code>关键字，因为传递过去后，<code>self</code>的指代关系已经不明确了。</p>
<blockquote>
<p>文档还提到<code>PythonRDD</code>的序列化是可定制的了，但是目前没这个需求，所有没测试</p>
</blockquote>
<h4 id="代码示例">代码示例</h4><p>java 测试代码， 编译生成 <code>pyspark-test.jar</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.valux.py4j;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqAdd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python 测试代码，放在文件 <code>driver.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> py4j.java_gateway <span class="keyword">import</span> java_import</span><br><span class="line"></span><br><span class="line">sc = SparkContext(appName=<span class="string">"Py4jTesting"</span>)</span><br><span class="line">java_import(sc._jvm, <span class="string">"org.valux.py4j.Calculate"</span>)</span><br><span class="line">func = sc._jvm.Calculate()</span><br><span class="line"><span class="keyword">print</span> func.sqAdd(<span class="number">5</span>)</span><br><span class="line"><span class="string">"""</span><br><span class="line">[OUTPUT] &gt; 26</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line"> ！！！[错误用法]</span><br><span class="line"> 这里是想在每个work上调用自定义的方法，</span><br><span class="line"> 前面已经提到过PySpark目前是不支持的</span><br><span class="line">"""</span></span><br><span class="line">rdd = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">result = rdd.map(func.sqAdd).collect()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span><br><span class="line"> ！！！[错误用法]</span><br><span class="line"> 之前还有个错误的思路是想在work单独 import 相应的 jar	</span><br><span class="line">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    java_import(sc._jvm, <span class="string">"org.valux.py4j.Calculate"</span>)</span><br><span class="line">    func = sc._jvm.Calculate()</span><br><span class="line">    func.sqAdd(x)</span><br><span class="line">rdd = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">rdd.map(foo).collect()</span><br></pre></td></tr></table></figure>
<p>测试时，提交程序需要记得带上jar包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/spar-submit --driver-class-path pyspark-test.jar driver.py</span><br></pre></td></tr></table></figure></p>
<p>这里又有一个坑，之前提交为了方便，一直都用的是 —jars 参数</p>
<blockquote>
<p>—driver-class-path 附加的 jar 只会在 <code>driver</code>引入<br>—jars 附加的jar会在所有<code>worker</code>引入</p>
</blockquote>
<p>帮助文档里面还提到 </p>
<blockquote>
<p>—jars Comma-separated list of local jars to include on the driver and executor classpaths.</p>
</blockquote>
<p>所有就偷个懒用了 —jars ，结果一直报如下错误:</p>
<blockquote>
<p>py4j.protocol.Py4JError: Trying to call a package.</p>
</blockquote>
<p>测试了好久终于解决了</p>
<h4 id="参考文档">参考文档</h4><blockquote>
<p><a href="https://cwiki.apache.org/confluence/display/SPARK/PySpark+Internals" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/SPARK/PySpark+Internals</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发<code>PySpark</code>程序时通常会需要用到Java的对象，而<code>PySpark</code>本身也是建立在Java API之上，通过Py4j来创建<code>JavaSparkContext</code>。</p>
<p><img src="]]>
    </summary>
    
      <category term="py4j" scheme="http://valux.cn/tags/py4j/"/>
    
      <category term="spark" scheme="http://valux.cn/tags/spark/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/essay/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PySpark操作HBase时设置scan参数]]></title>
    <link href="http://valux.cn/2015/05/12/5d61b98314663d23/"/>
    <id>http://valux.cn/2015/05/12/5d61b98314663d23/</id>
    <published>2015-05-11T16:04:31.000Z</published>
    <updated>2015-07-31T19:48:57.602Z</updated>
    <content type="html"><![CDATA[<p>在用PySpark操作HBase时默认是<code>scan</code>操作，通常情况下我们希望加上<code>rowkey</code>指定范围，即只获取一部分数据参加运算。翻遍了spark的python相关文档，搜遍了<code>google</code>和<code>stackoverflow</code>也没有具体的解决方案。既然java和scala都支持，python肯定也支持的。</p>
<p>翻了一下hbase源码 </p>
<blockquote>
<p><a href="https://github.com/apache/hbase/blob/master/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableInputFormat.java" target="_blank" rel="external"><code>org.apache.hadoop.hbase.mapreduce.TableInputFormat</code></a></p>
</blockquote>
<p><code>setConf</code>方法里原来是根据特定的字符串对<code>scan</code>进行配置，那么在Python里对conf就可以进行相应的设置，这些设置主要包括：</p>
<blockquote>
<p><code>hbase.mapreduce.scan.row.start</code><br><code>hbase.mapreduce.scan.row.stop</code><br><code>hbase.mapreduce.scan.column.family</code><br><code>hbase.mapreduce.scan.columns</code><br><code>hbase.mapreduce.scan.timestamp</code><br><code>hbase.mapreduce.scan.timerange.start</code><br><code>hbase.mapreduce.scan.timerange.end</code><br><code>hbase.mapreduce.scan.maxversions</code><br><code>hbase.mapreduce.scan.cacheblocks</code><br><code>hbase.mapreduce.scan.cachedrows</code><br><code>hbase.mapreduce.scan.batchsize</code>  </p>
</blockquote>
<p>首先创建测试表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; create <span class="string">'test'</span>, <span class="string">'f1'</span></span><br><span class="line">hbase&gt; put <span class="string">'test'</span>, <span class="string">'row1'</span>, <span class="string">'f1'</span>, <span class="string">'value1'</span></span><br><span class="line">hbase&gt; put <span class="string">'test'</span>, <span class="string">'row2'</span>, <span class="string">'f1'</span>, <span class="string">'value2'</span></span><br><span class="line">hbase&gt; put <span class="string">'test'</span>, <span class="string">'row3'</span>, <span class="string">'f1'</span>, <span class="string">'value3'</span></span><br><span class="line">hbase&gt; put <span class="string">'test'</span>, <span class="string">'row4'</span>, <span class="string">'f1'</span>, <span class="string">'value4'</span></span><br></pre></td></tr></table></figure></p>
<p>然后，设置scan范围的示例代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sc = SparkContext(appName=settings.APP_NAME)</span><br><span class="line">conf = &#123;</span><br><span class="line">        <span class="string">"hbase.zookeeper.quorum"</span>: settings.HBASE_HOST,</span><br><span class="line">        <span class="string">"hbase.mapreduce.inputtable"</span>: <span class="string">"test"</span>,</span><br><span class="line">        <span class="string">"hbase.mapreduce.scan.row.start"</span>: <span class="string">"row2"</span></span><br><span class="line">    &#125;</span><br><span class="line">rdd = sc.newAPIHadoopRDD(</span><br><span class="line">    <span class="string">"org.apache.hadoop.hbase.mapreduce.TableInputFormat"</span>,</span><br><span class="line">    <span class="string">"org.apache.hadoop.hbase.io.ImmutableBytesWritable"</span>,</span><br><span class="line">    <span class="string">"org.apache.hadoop.hbase.client.Result"</span>,</span><br><span class="line">    keyConverter=<span class="string">"org.valux.converters.ImmutableBytesWritableToStringConverter"</span>,</span><br><span class="line">    valueConverter=<span class="string">"org.valux.converters.HBaseResultToStringConverter"</span>,</span><br><span class="line">    conf=conf)</span><br><span class="line">result = rdd.collect()</span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> result</span><br><span class="line">    <span class="keyword">print</span> k, v</span><br></pre></td></tr></table></figure>
<p><code>org.valux.converters.ImmutableBytesWritableToStringConverter</code><br><code>org.valux.converters.HBaseResultToStringConverter</code></p>
<p>是我自己实现的两个转换类，也可以用spark默认自带的converter，具体可以参考<code>hbase_inputformat.py</code>，不过提交时要带上相应的jar包</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在用PySpark操作HBase时默认是<code>scan</code>操作，通常情况下我们希望加上<code>rowkey</code>指定范围，即只获取一部分数据参加运算。翻遍了spark的python相关文档，搜遍了<code>google</code>和<code]]>
    </summary>
    
      <category term="hbase" scheme="http://valux.cn/tags/hbase/"/>
    
      <category term="scan" scheme="http://valux.cn/tags/scan/"/>
    
      <category term="spark" scheme="http://valux.cn/tags/spark/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/essay/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spark RDD操作(Python)总结]]></title>
    <link href="http://valux.cn/2015/05/11/bc7bf5dca5cd6d8f/"/>
    <id>http://valux.cn/2015/05/11/bc7bf5dca5cd6d8f/</id>
    <published>2015-05-10T16:04:31.000Z</published>
    <updated>2015-07-31T19:49:17.348Z</updated>
    <content type="html"><![CDATA[<p>Spark 提供了很多<code>Transformation</code>用于创建<code>RDD</code>，总结如下（Python）</p>
<h4 id="map(func)">map(func)</h4><blockquote>
<p>将原RDD中每个元素代入带入<code>func</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd.map(<span class="keyword">lambda</span> x: x*x).collect()</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h4 id="filter(func)">filter(func)</h4><blockquote>
<p>返回包含所有在<code>func</code>中结果为<code>True</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd.filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">2</span>).collect()</span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h4 id="flatMap(func)">flatMap(func)</h4><blockquote>
<p>将原RDD中的每一个元素映射为0个或者多个元素，每次map过程的返回值必须是集合（可空）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd.flatMap(<span class="keyword">lambda</span> x: range(<span class="number">1</span>, x))</span><br><span class="line">// [] || [<span class="number">1</span>] || [<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="mapPartitions(func)">mapPartitions(func)</h4><blockquote>
<p>将<code>func</code>方法分别应用于各个分区</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line">// 两个分区的数据分别为 [<span class="number">1</span>,<span class="number">2</span>] [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">yield</span> sum(x)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd.mapPartitions(f).collect()</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h4 id="mapPartitionsWithIndex(func)">　mapPartitionsWithIndex(func)</h4><blockquote>
<p>和<a href="#mapPartitions">mapPartitions</a>方法一样， <code>func</code>传入参数增加index</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i, x)</span>:</span> <span class="keyword">yield</span> i*sum(x)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd.mapPartitionsWithIndex(f).collect()</span><br><span class="line">//[<span class="number">0</span>*(<span class="number">1</span>+<span class="number">2</span>), <span class="number">1</span>*(<span class="number">3</span>+<span class="number">4</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h4 id="sample(withReplacement,_fraction,_seed)">sample(withReplacement, fraction, seed)</h4><blockquote>
<p>对已有的RDD进行采样,<br><code>withReplacement</code> 布尔型， 表示是否用随机值替换<br><code>fraction</code> 采样比例<br><code>seed</code> 随机种子数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd = sc.parallelize(range(<span class="number">100</span>))</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd.sample(<span class="keyword">False</span>, <span class="number">0.2</span>, <span class="number">81</span>).count()</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<h4 id="union(RDD)">union(RDD)</h4><blockquote>
<p>合并两个已有的RDD，返回新一个的新的RDD</p>
</blockquote>
<h4 id="intersection(RDD)">intersection(RDD)</h4><blockquote>
<p>求两个RDD的交集，并去重，会引发洗牌操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd2 = sc.parallelize([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>rdd1.intersection(rdd2).collect()</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="distinct()">distinct()</h4><blockquote>
<p>对RDD的元素去重</p>
</blockquote>
<h4 id="groupByKey()">groupByKey()</h4>]]></content>
    <summary type="html">
    <![CDATA[<p>Spark 提供了很多<code>Transformation</code>用于创建<code>RDD</code>，总结如下（Python）</p>
<h4 id="map(func)">map(func)</h4><blockquote>
<p>将原RDD中每个元素代入]]>
    </summary>
    
      <category term="rdd" scheme="http://valux.cn/tags/rdd/"/>
    
      <category term="spark" scheme="http://valux.cn/tags/spark/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/essay/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spark 下操作 HBase（1.0.0 新 API）]]></title>
    <link href="http://valux.cn/2015/05/09/3dbb31482e5d12c5/"/>
    <id>http://valux.cn/2015/05/09/3dbb31482e5d12c5/</id>
    <published>2015-05-08T16:04:31.000Z</published>
    <updated>2015-07-31T19:49:55.483Z</updated>
    <content type="html"><![CDATA[<p>HBase经过七年发展，终于在今年2月底，发布了 1.0.0 版本。这个版本提供了一些让人激动的功能，并且，在不牺牲稳定性的前提下，引入了新的API。虽然 1.0.0 兼容旧版本的 API，不过还是应该尽早地来熟悉下新版API。并且了解下如何与当下正红的 Spark 结合，进行数据的写入与读取。鉴于国内外有关 HBase 1.0.0 新 API 的资料甚少，故作此文。<br>本文将分两部分介绍，第一部分讲解使用 HBase 新版 API 进行 CRUD 基本操作；第二部分讲解如何将 Spark 内的 RDDs 写入 HBase 的表中，反之，HBase 中的表又是如何以 RDDs 形式加载进 Spark 内的。</p>
<h3 id="环境配置">　环境配置</h3><p>为了避免版本不一致带来不必要的麻烦，API 和 HBase环境都是 1.0.0 版本。HBase 为单机模式，分布式模式的使用方法类似，只需要修改<code>HBaseConfiguration</code>的配置即可。</p>
<p>开发环境中使用 SBT 加载依赖项<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"SparkLearn"</span></span><br><span class="line">version := <span class="string">"1.0"</span></span><br><span class="line">scalaVersion := <span class="string">"2.10.4"</span></span><br><span class="line">libraryDependencies += <span class="string">"org.apache.spark"</span> %% <span class="string">"spark-core"</span> % <span class="string">"1.3.0"</span></span><br><span class="line">libraryDependencies += <span class="string">"org.apache.hbase"</span> % <span class="string">"hbase-client"</span> % <span class="string">"1.0.0"</span></span><br><span class="line">libraryDependencies += <span class="string">"org.apache.hbase"</span> % <span class="string">"hbase-common"</span> % <span class="string">"1.0.0"</span></span><br><span class="line">libraryDependencies += <span class="string">"org.apache.hbase"</span> % <span class="string">"hbase-server"</span> % <span class="string">"1.0.0"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="HBase_的_CRUD_操作">HBase 的 CRUD 操作</h3><p>新版 API 中加入了 <code>Connection</code>，<code>HAdmin</code>成了<code>Admin</code>，<code>HTable</code>成了<code>Table</code>，而<code>Admin</code>和<code>Table</code>只能通过<code>Connection</code>获得。<code>Connection的</code>创建是个重量级的操作，由于<code>Connection</code>是线程安全的，所以推荐使用单例，其工厂方法需要一个<code>HBaseConfiguration</code>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">conf</span> =</span> <span class="type">HBaseConfiguration</span>.create()</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"2181"</span>)</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"master"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Connection 的创建是个重量级的工作，线程安全，是操作hbase的入口</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">conn</span> =</span> <span class="type">ConnectionFactory</span>.createConnection(conf)</span><br></pre></td></tr></table></figure></p>
<h3 id="创建表">创建表</h3><p>使用<code>Admin</code>创建和删除表<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">userTable</span> =</span> <span class="type">TableName</span>.valueOf(<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 user 表</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tableDescr</span> =</span> <span class="keyword">new</span> <span class="type">HTableDescriptor</span>(userTable)</span><br><span class="line">tableDescr.addFamily(<span class="keyword">new</span> <span class="type">HColumnDescriptor</span>(<span class="string">"basic"</span>.getBytes))</span><br><span class="line">println(<span class="string">"Creating table `user`. "</span>)</span><br><span class="line"><span class="keyword">if</span> (admin.tableExists(userTable)) &#123;</span><br><span class="line">  admin.disableTable(userTable)</span><br><span class="line">  admin.deleteTable(userTable)</span><br><span class="line">&#125;</span><br><span class="line">admin.createTable(tableDescr)</span><br><span class="line">println(<span class="string">"Done!"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="插入、查询、扫描、删除操作">插入、查询、扫描、删除操作</h3><p>HBase 上的操作都需要先创建一个操作对象Put,Get,Delete等，然后调用Table上的相对应的方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//获取 user 表</span></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">table</span> =</span> conn.getTable(userTable)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//准备插入一条 key 为 id001 的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">p</span> =</span> <span class="keyword">new</span> <span class="type">Put</span>(<span class="string">"id001"</span>.getBytes)</span><br><span class="line">    <span class="comment">//为put操作指定 column 和 value （以前的 put.add 方法被弃用了）</span></span><br><span class="line">    p.addColumn(<span class="string">"basic"</span>.getBytes,<span class="string">"name"</span>.getBytes, <span class="string">"wuchong"</span>.getBytes)</span><br><span class="line">    <span class="comment">//提交</span></span><br><span class="line">    table.put(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某条数据</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">g</span> =</span> <span class="keyword">new</span> <span class="type">Get</span>(<span class="string">"id001"</span>.getBytes)</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">result</span> =</span> table.get(g)</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">value</span> =</span> <span class="type">Bytes</span>.toString(result.getValue(<span class="string">"basic"</span>.getBytes,<span class="string">"name"</span>.getBytes))</span><br><span class="line">    println(<span class="string">"GET id001 :"</span>+value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扫描数据</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">s</span> =</span> <span class="keyword">new</span> <span class="type">Scan</span>()</span><br><span class="line">    s.addColumn(<span class="string">"basic"</span>.getBytes,<span class="string">"name"</span>.getBytes)</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">scanner</span> =</span> table.getScanner(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(r &lt;- scanner)&#123;</span><br><span class="line">        println(<span class="string">"Found row: "</span>+r)</span><br><span class="line">        println(<span class="string">"Found value: "</span>+<span class="type">Bytes</span>.toString(</span><br><span class="line">          r.getValue(<span class="string">"basic"</span>.getBytes,<span class="string">"name"</span>.getBytes)))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//确保scanner关闭</span></span><br><span class="line">      scanner.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除某条数据,操作方式与 Put 类似</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">d</span> =</span> <span class="keyword">new</span> <span class="type">Delete</span>(<span class="string">"id001"</span>.getBytes)</span><br><span class="line">    d.addColumn(<span class="string">"basic"</span>.getBytes,<span class="string">"name"</span>.getBytes)</span><br><span class="line">    table.delete(d)</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(table != <span class="literal">null</span>) table.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  conn.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spark_操作_HBase">Spark 操作 HBase</h3><p>首先要向 HBase 写入数据，我们需要用到<code>PairRDDFunctions.saveAsHadoopDataset</code>。因为 HBase 不是一个文件系统，所以<code>saveAsHadoopFile</code>方法没用。</p>
<blockquote>
<p>def saveAsHadoopDataset(conf: JobConf): Unit<br>Output the RDD to any Hadoop-supported storage system, using a Hadoop JobConf object for that storage system</p>
</blockquote>
<p>这个方法需要一个 JobConf 作为参数，类似于一个配置项，主要需要指定输出的格式和输出的表名。</p>
<h4 id="Step_1：我们需要先创建一个_JobConf">Step 1：我们需要先创建一个 JobConf</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/定义 <span class="type">HBase</span> 的配置</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">conf</span> =</span> <span class="type">HBaseConfiguration</span>.create()</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"2181"</span>)</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"master"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定输出格式和输出表名</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">jobConf</span> =</span> <span class="keyword">new</span> <span class="type">JobConf</span>(conf,<span class="keyword">this</span>.getClass)</span><br><span class="line">jobConf.setOutputFormat(classOf[<span class="type">TableOutputFormat</span>])</span><br><span class="line">jobConf.set(<span class="type">TableOutputFormat</span>.<span class="type">OUTPUT_TABLE</span>,<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Step_2：_RDD_到表模式的映射">Step 2： RDD 到表模式的映射</h4><p>在 HBase 中的表 schema 一般是这样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row     cf:col_1    cf:col_2</span><br></pre></td></tr></table></figure></p>
<p>而在Spark中，我们操作的是RDD元组，比如<code>(1,&quot;lilei&quot;,14)</code>, <code>(2,&quot;hanmei&quot;,18)</code>。我们需要将 <code>RDD[(uid:Int, name:String, age:Int)]</code> 转换成<code>RDD[(ImmutableBytesWritable, Put)]</code>。所以，我们定义一个 convert 函数做这个转换工作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(</span>triple: (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">p</span> =</span> <span class="keyword">new</span> <span class="type">Put</span>(<span class="type">Bytes</span>.toBytes(triple._1))</span><br><span class="line">      p.addColumn(<span class="type">Bytes</span>.toBytes(<span class="string">"basic"</span>),<span class="type">Bytes</span>.toBytes(<span class="string">"name"</span>),<span class="type">Bytes</span>.toBytes(triple._2))</span><br><span class="line">      p.addColumn(<span class="type">Bytes</span>.toBytes(<span class="string">"basic"</span>),<span class="type">Bytes</span>.toBytes(<span class="string">"age"</span>),<span class="type">Bytes</span>.toBytes(triple._3))</span><br><span class="line">      (<span class="keyword">new</span> <span class="type">ImmutableBytesWritable</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Step_3：_读取RDD并转换">Step 3： 读取RDD并转换</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read RDD data from somewhere and convert</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">rawData</span> =</span> <span class="type">List</span>((<span class="number">1</span>,<span class="string">"lilei"</span>,<span class="number">14</span>), (<span class="number">2</span>,<span class="string">"hanmei"</span>,<span class="number">18</span>), (<span class="number">3</span>,<span class="string">"someone"</span>,<span class="number">38</span>))</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">localData</span> =</span> sc.parallelize(rawData).map(convert)</span><br></pre></td></tr></table></figure>
<h4 id="Step_4：_使用saveAsHadoopDataset方法写入HBase">Step 4： 使用saveAsHadoopDataset方法写入HBase</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localData.saveAsHadoopDataset(jobConf)</span><br></pre></td></tr></table></figure>
<h3 id="读取_HBase">读取 HBase</h3><p>Spark读取HBase，我们主要使用<code>SparkContext</code>提供的<code>newAPIHadoopRDDAPI</code>将表的内容以 RDDs 的形式加载到 Spark 中</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val conf = <span class="type">HBaseConfiguration</span>.create()</span><br><span class="line">conf.<span class="type">set</span>(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"2181"</span>)</span><br><span class="line">conf.<span class="type">set</span>(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"master"</span>)</span><br><span class="line"></span><br><span class="line">//设置查询的表名</span><br><span class="line">conf.<span class="type">set</span>(<span class="type">TableInputFormat</span>.<span class="type">INPUT_TABLE</span>, <span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">val usersRDD = sc.newAPIHadoopRDD(conf, classOf[<span class="type">TableInputFormat</span>],</span><br><span class="line">  classOf[org.apache.hadoop.hbase.io.<span class="type">ImmutableBytesWritable</span>],</span><br><span class="line">  classOf[org.apache.hadoop.hbase.client.<span class="type">Result</span>])</span><br><span class="line"></span><br><span class="line">val count = usersRDD.count()</span><br><span class="line">println(<span class="string">"Users RDD Count:"</span> + count)</span><br><span class="line">usersRDD.cache()</span><br><span class="line"></span><br><span class="line">//遍历输出</span><br><span class="line">usersRDD.foreach&#123; <span class="keyword">case</span> (_,<span class="literal">result</span>) =&gt;</span><br><span class="line">  val key = <span class="type">Bytes</span>.toInt(<span class="literal">result</span>.getRow)</span><br><span class="line">  val name = <span class="type">Bytes</span>.toString(<span class="literal">result</span>.getValue(<span class="string">"basic"</span>.getBytes,<span class="string">"name"</span>.getBytes))</span><br><span class="line">  val age = <span class="type">Bytes</span>.toInt(<span class="literal">result</span>.getValue(<span class="string">"basic"</span>.getBytes,<span class="string">"age"</span>.getBytes))</span><br><span class="line">  println(<span class="string">"Row key:"</span>+key+<span class="string">" Name:"</span>+name+<span class="string">" Age:"</span>+age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文档">参考文档</h3><blockquote>
<p>作者： WuChong<br>原文： <a href="http://wuchong.me/blog/2015/04/06/spark-on-hbase-new-api/" target="_blank" rel="external">http://wuchong.me/blog/2015/04/06/spark-on-hbase-new-api/</a>    </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>HBase经过七年发展，终于在今年2月底，发布了 1.0.0 版本。这个版本提供了一些让人激动的功能，并且，在不牺牲稳定性的前提下，引入了新的API。虽然 1.0.0 兼容旧版本的 API，不过还是应该尽早地来熟悉下新版API。并且了解下如何与当下正红的 Spark 结合，]]>
    </summary>
    
      <category term="hbase" scheme="http://valux.cn/tags/hbase/"/>
    
      <category term="spark" scheme="http://valux.cn/tags/spark/"/>
    
      <category term="share" scheme="http://valux.cn/categories/share/"/>
    
      <category term="bigdat" scheme="http://valux.cn/categories/share/bigdat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Django中如何使用django-celery完成异步任务]]></title>
    <link href="http://valux.cn/2015/05/03/35327bdac4ff4337/"/>
    <id>http://valux.cn/2015/05/03/35327bdac4ff4337/</id>
    <published>2015-05-02T20:05:58.000Z</published>
    <updated>2015-07-31T19:46:54.623Z</updated>
    <content type="html"><![CDATA[<p>本篇博文主要介绍在开发环境中的celery使用,请勿用于部署服务器.</p>
<p>许多Django应用需要执行异步任务, 以便不耽误http request的执行. 我们也可以选择许多方法来完成异步任务, 使用Celery是一个比较好的选择, 因为Celery有着大量的社区支持, 能够完美的扩展, 和Django结合的也很好. Celery不仅能在Django中使用, 还能在其他地方被大量的使用. 因此一旦学会使用Celery, 我们可以很方便的在其他项目中使用它.</p>
<h3 id="1-_Celery版本">1. Celery版本</h3><p>本篇博文主要针对Celery 3.0.x. 早期版本的Celery可能有细微的差别.</p>
<h3 id="2-_Celery介绍">2. Celery介绍</h3><p>Celery的主要用处是执行异步任务, 可以选择延期或定时执行功能. 为什么需要执行异步任务呢?</p>
<p>第一, 假设用户正发起一个request, 并等待request完成后返回. 在这一request后面的view功能中, 我们可能需要执行一段花费很长时间的程序任务, 这一时间可能远远大于用户能忍受的范围. 当这一任务并不需要立刻执行时, 我们便可以使用Celery在后台执行, 而不影响用户浏览网页. 当有任务需要访问远程服务器完成时, 我们往往都无法确定需要花费的时间.</p>
<p>第二则是定期执行某些任务. 比如每小时需要检查一下天气预报, 然后将数据储存到数据库中. 我们可以编写这一任务, 然后让Celery每小时执行一次. 这样我们的web应用便能获取最新的天气预报信息.</p>
<p>我们这里所讲的任务task, 就是一个Python功能(function). 定期执行一个任务可以被认为是延时执行该功能. 我们可以使用Celery延迟5分钟调用function task1, 并传入参数(1, 2, 3). 或者我们也可以每天午夜运行该function.</p>
<p>我们偏向于将Celery放入项目中, 便于task访问统一数据库和Django设置.</p>
<p>当task准备运行时, Celery会将其放入列队queue中. queue中储存着可以运行的task的list. 我们可以使用多个queue, 但为了简单, 这里我们只使用一个.</p>
<p>将任务task放入queue就像加入todo list一样. 为了使task运行, 我们还需要在其他线程中运行的苦工worker. worker实时观察着代运行的task, 并逐一运行这些task. 你可以使用多个worker, 通常他们位于不同服务器上. 同样为了简单起见, 我们这只是用一个worker.</p>
<p>我们稍后会讨论queue, worker和另外一个十分重要的进程, 接下来我们来动动手:</p>
<h3 id="3-_安装Celery">3. 安装Celery</h3><p>我们可以使用pip在vietualenv中安装:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-celery</span><br></pre></td></tr></table></figure></p>
<h3 id="4-_Django设置">4. Django设置</h3><p>我们暂时使用django runserver来启动celery. 而Celery代理人(broker), 我们使用Django database broker implementation. 现在我们只需要知道Celery需要broker, 使用django自身便可以充当broker. (但在部署时, 我们最好使用更稳定和高效的broker, 例如Redis.)</p>
<p>在settings.py中:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import djcelery</span><br><span class="line">   djcelery.setup_loader()</span><br><span class="line">   BROKER_URL = 'django://'</span><br><span class="line">   ...</span><br><span class="line">   INSTALLED_APPS = (</span><br><span class="line">      ...</span><br><span class="line">      'djcelery',</span><br><span class="line">      'kombu.transport.django',</span><br><span class="line">      ...</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></p>
<p>第一二项是必须的, 第三项则告诉Celery使用Django项目作为broker.</p>
<p>在INSTALLED_APPS中添加的djcelery是必须的. kombu.transport.django则是基于Django的broker</p>
<p>最后创建Celery所需的数据表, 如果使用South作为数据迁移工具, 则运行:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></p>
<p>否则运行: (Django 1.6或Django 1.7都可以)<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py syncdb</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_创建一个task">5. 创建一个task</h3><p>正如前面所说的, 一个task就是一个Pyhton function. 但Celery需要知道这一function是task, 因此我们可以使用celery自带的装饰器decorator: @task. 在django app目录中创建taske.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line">  <span class="decorator">@task()</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p>
<p>当settings.py中的djcelery.setup_loader()运行时, Celery便会查看所有INSTALLED_APPS中app目录中的tasks.py文件, 找到标记为task的function, 并将它们注册为celery task.</p>
<p>将function标注为task并不会妨碍他们的正常执行. 你还是可以像平时那样调用它: z = add(1, 2).</p>
<h3 id="6-_执行task">6. 执行task</h3><p>让我们以一个简单的例子作为开始. 例如我们希望在用户发出request后异步执行该task, 马上返回response, 从而不阻塞该request, 使用户有一个流畅的访问过程. 那么, 我们可以使用.delay, 例如在在views.py的一个view中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp.tasks <span class="keyword">import</span> add</span><br><span class="line">    ...</span><br><span class="line">        add.delay(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>Celery会将task加入到queue中, 并马上返回. 而在一旁待命的worker看到该task后, 便会按照设定执行它, 并将他从queue中移除. 而worker则会执行以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myapp.tasks.add</span><br><span class="line">myapp.tasks.add(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="7-_关于import">7. 关于import</h3><p>这里需要注意的是, 在impprt task时, 需要保持一致. 因为在执行djcelery.setup_loader()时, task是以INSTALLED_APPS中的app名, 加.tasks.function_name注册的, 如果我们由于python path不同而使用不同的引用方式时(例如在tasks.py中使用from myproject.myapp.tasks import add形式), Celery将无法得知这是同一task, 因此可能会引起奇怪的bug.</p>
<h3 id="8-_测试">8. 测试</h3><h4 id="8-1_启动worker">8.1 启动worker</h4><p>正如之前说到的, 我们需要worker来执行task. 以下是在开发环境中的如何启动worker:</p>
<p>首先启动terminal, 如同开发django项目一样, 激活virtualenv, 切换到django项目目录. 然后启动django自带web服务器: python manage.py runserver.</p>
<p>然后启动worker:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py celery worker --loglevel=info</span><br></pre></td></tr></table></figure></p>
<p>此时, worker将会在该terminal中运行, 并显示输出结果.</p>
<h4 id="8-2_启动task">8.2 启动task</h4><p>打开新的terminal, 激活virtualenv, 并切换到django项目目录:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py shell</span><br><span class="line">&gt;&gt;&gt; from myapp.tasks import add</span><br><span class="line">&gt;&gt;&gt; add.delay(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时, 你可以在worker窗口中看到worker执行该task:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2014-10-07</span> <span class="number">08:47:08,07</span>6: INFO/MainProcess] Got task from broker: myapp.tasks.add[e<span class="number">080e047</span>-b<span class="number">2a2-43a7</span>-af74-d<span class="number">7d9d98b02</span>fc]</span><br><span class="line">[<span class="number">2014-10-07</span> <span class="number">08:47:08,29</span>9: INFO/MainProcess] Task myapp.tasks.add[e<span class="number">080e047</span>-b<span class="number">2a2-43a7</span>-af74-d<span class="number">7d9d98b02</span>fc] succeeded in <span class="number">0.183349132</span>538s: 4</span><br></pre></td></tr></table></figure></p>
<h3 id="9-_另一个例子">9. 另一个例子</h3><p>下面我们来看一个更为真实的例子, 在views.py和tasks.py中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> myapp.tasks <span class="keyword">import</span> do_something_with_form_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request)</span>:</span></span><br><span class="line">    form = SomeForm(request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        data = form.cleaned_data</span><br><span class="line">        <span class="comment"># Schedule a task to process the data later</span></span><br><span class="line">        do_something_with_form_data.delay(data)</span><br><span class="line">    <span class="keyword">return</span> render_to_response(...)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"></span><br><span class="line"><span class="decorator">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something_with_form_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    call_slow_web_service(data[<span class="string">'user'</span>], data[<span class="string">'text'</span>], ...)</span><br></pre></td></tr></table></figure>
<h3 id="10-_调试">10. 调试</h3><p>由于Celery的运行需要启动多个部件, 我们可能会漏掉一两个. 所以我们建议:</p>
<blockquote>
<p>使用最简单的设置<br>使用python debug和logging功能显示当前的进程  </p>
</blockquote>
<h3 id="11-_Eager模式">11. Eager模式</h3><p>如果在settings.py设置:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CELERY_ALWAYS_EAGER = <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>那么Celery便以eager模式运行, 则task便不需要加delay运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若启用eager模式, 则以下两行代码相同</span></span><br><span class="line">add.delay(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="12-_查看queue">12. 查看queue</h3><p>因为我们使用了django作为broker, queue储存在django的数据库中. 这就意味着我们可以通过django admin查看该queue:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> kombu.transport.django <span class="keyword">import</span> models <span class="keyword">as</span> kombu_models</span><br><span class="line"></span><br><span class="line">admin.site.register(kombu_models.Message)</span><br></pre></td></tr></table></figure></p>
<h3 id="13-_检查结果">13. 检查结果</h3><p>每次运行异步task后, Celery都会返回AsyncResult对象作为结果. 你可以将其保存, 然后在将来查看该task是否运行成功和返回结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"></span><br><span class="line">result = add.delay(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> result.ready():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Task has run"</span></span><br><span class="line">    <span class="keyword">if</span> result.successful():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Result was: %s"</span> % result.result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> isinstance(result.result, Exception):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Task failed due to raising an exception"</span></span><br><span class="line">            <span class="keyword">raise</span> result.result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Task failed without raising exception"</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"Task has not yet run"</span></span><br></pre></td></tr></table></figure>
<h3 id="14-_定期任务">14. 定期任务</h3><p>还有一种Celery的常用模式便是执行定期任务. 执行定期任务时, Celery会通过celerybeat进程来完成. Celerybeat会保持运行, 一旦到了某一定期任务需要执行时, Celerybeat便将其加入到queue中. 不像worker进程, Celerybeat只有需要一个即可.</p>
<p>启动Celerybeat:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py celery beat</span><br></pre></td></tr></table></figure></p>
<p>使Celery运行定期任务的方式有很多种, 我们先看第一种, 将定期任务储存在django数据库中. 即使是在django和celery都运行的状态, 这一方式也可以让我们方便的修改定期任务. 我们只需要设置settings.py中的一项便能开启这一方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># settings.py</span></span><br><span class="line">CELERYBEAT_SCHEDULER = <span class="string">'djcelery.schedulers.DatabaseScheduler'</span></span><br></pre></td></tr></table></figure>
<p>然后我们便可以通过django admin的/admin/djcelery/periodictask/添加定期任务了.</p>
<blockquote>
<p>Name: 这一定期任务的注册名<br>Task (registered): 可以选择所有已经注册的task之一, 例如前面的add function<br>Task (custom): task的全名, 例如myapp.tasks.add, 但最好还是用以上项<br>Enabled: 是否开启这一定期任务<br>Interval: 定期任务的间隔时间, 例如每隔5分钟<br>Crontab: 如果希望task在某一特定时间运行, 则使用Unix中的Crontab代替interval<br>Arguments: 用于传参数到task中<br>Execution Options: 更高级的设置, 在此不详细说明, 请查看celery官方文档</p>
</blockquote>
<h3 id="15-_注意">15. 注意</h3><p>本篇博文中所描述的方法只适用于开发环境, 而不应当应用于部署环境.</p>
<p>如果希望在部署环境中使用, 最重要的便是使用更稳定和可扩展的broker, 而不是使用kombu.transport.django.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇博文主要介绍在开发环境中的celery使用,请勿用于部署服务器.</p>
<p>许多Django应用需要执行异步任务, 以便不耽误http request的执行. 我们也可以选择许多方法来完成异步任务, 使用Celery是一个比较好的选择, 因为Celery有着大量的社]]>
    </summary>
    
      <category term="celery" scheme="http://valux.cn/tags/celery/"/>
    
      <category term="django" scheme="http://valux.cn/tags/django/"/>
    
      <category term="异步" scheme="http://valux.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="python" scheme="http://valux.cn/categories/essay/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[探究Spark的shuffle实现]]></title>
    <link href="http://valux.cn/2015/04/29/6c6ee2bdea10708f/"/>
    <id>http://valux.cn/2015/04/29/6c6ee2bdea10708f/</id>
    <published>2015-04-28T19:50:10.000Z</published>
    <updated>2015-07-31T19:50:19.052Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/" target="_blank">http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/</a>    作者：Jerry Shao<a href="http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/" target="_blank"></a></p><h3 id="background" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 24.5px;">Background</h3><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在MapReduce框架中，shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了整个程序的性能和吞吐量。Spark作为MapReduce框架的一种实现，自然也实现了shuffle的逻辑，本文就深入研究Spark的shuffle是如何实现的，有什么优缺点，与Hadoop MapReduce的shuffle有什么不同。</p><h2 id="shuffle" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 31.5px;">Shuffle</h2><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">Shuffle是MapReduce框架中的一个特定的phase，介于Map phase和Reduce phase之间，当Map的输出结果要被Reduce使用时，输出结果需要按key哈希，并且分发到每一个Reducer上去，这个过程就是shuffle。由于shuffle涉及到了磁盘的读写和网络的传输，因此shuffle性能的高低直接影响到了整个程序的运行效率。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">下面这幅图清晰地描述了MapReduce算法的整个流程，其中shuffle phase是介于Map phase和Reduce phase之间。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="mapreduce running process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-process.jpg" width="640" style="max-width: 100%; height: auto;"></p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">概念上shuffle就是一个沟通数据连接的桥梁，那么实际上shuffle这一部分是如何实现的的呢，下面我们就以Spark为例讲一下shuffle在Spark中的实现。</p><h2 id="spark_shuffle" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 31.5px;">Spark Shuffle进化史</h2><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">先以图为例简单描述一下Spark中shuffle的整一个流程：</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="spark shuffle process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle.png" width="640" style="max-width: 100%; height: auto;"></p><ul style="padding: 0px; margin-right: 0px; margin-left: 25px; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><li>首先每一个Mapper会根据Reducer的数量创建出相应的bucket，bucket的数量是<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-1-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-1" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.753em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.098em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-3" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">M<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span><span class="mo" id="MathJax-Span-4" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Main;">×</span><span class="mi" id="MathJax-Span-5" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>，其中<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-2-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-6" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 1.313em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 1.074em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-7" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-8" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">M<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 0.932em;"></span></span></nobr></span>是Map的个数，<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-3-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-9" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.955em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.777em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-10" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-11" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>是Reduce的个数。</li><li>其次Mapper产生的结果会根据设置的partition算法填充到每个bucket中去。这里的partition算法是可以自定义的，当然默认的算法是根据key哈希到不同的bucket中去。</li><li>当Reducer启动时，它会根据自己task的id和所依赖的Mapper的id从远端或是本地的block manager中取得相应的bucket作为Reducer的输入进行处理。</li></ul><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">这里的bucket是一个抽象概念，在实现中每个bucket可以对应一个文件，可以对应文件的一部分或是其他等。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">接下来我们分别从<strong>shuffle write</strong>和<strong>shuffle fetch</strong>这两块来讲述一下Spark的shuffle进化史。</p><h3 id="shuffle_write" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 24.5px;">Shuffle Write</h3><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在Spark 0.6和0.7的版本中，对于shuffle数据的存储是以文件的方式存储在block manager中，与<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">rdd.persist(StorageLevel.DISk<em>ONLY)</em></code>采取相同的策略，可以参看：<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(</span>attemptId: <span class="type">Long</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">blockManager</span> =</span> <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line">  <span class="keyword">var</span> shuffle: <span class="type">ShuffleBlocks</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> buckets: <span class="type">ShuffleWriterGroup</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Obtain all the block writers for shuffle blocks.</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">ser</span> =</span> <span class="type">SparkEnv</span>.get.serializerManager.get(dep.serializerClass)</span><br><span class="line">    shuffle = blockManager.shuffleBlockManager.forShuffle(dep.shuffleId, numOutputSplits, ser)</span><br><span class="line">    buckets = shuffle.acquireWriters(partition)</span><br><span class="line">    <span class="comment">// Write the map output to its associated buckets.</span></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- rdd.iterator(split, taskContext)) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">pair</span> =</span> elem.asInstanceOf[<span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">bucketId</span> =</span> dep.partitioner.getPartition(pair._1)</span><br><span class="line">      buckets.writers(bucketId).write(pair)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commit the writes. Get the size of each bucket block (total block size).</span></span><br><span class="line">    <span class="keyword">var</span> totalBytes = <span class="number">0</span>L</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">compressedSizes</span>:</span> <span class="type">Array</span>[<span class="type">Byte</span>] = buckets.writers.map &#123; writer:   <span class="type">BlockObjectWriter</span> =&gt;</span><br><span class="line">      writer.commit()</span><br><span class="line">      writer.close()</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">size</span> =</span> writer.size()</span><br><span class="line">      totalBytes += size</span><br><span class="line">      <span class="type">MapOutputTracker</span>.compressSize(size)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">    <span class="comment">// If there is an exception from running the task, revert the partial writes</span></span><br><span class="line">    <span class="comment">// and throw the exception upstream to Spark.</span></span><br><span class="line">    <span class="keyword">if</span> (buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      buckets.writers.foreach(_.revertPartialWrites())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Release the writers back to the shuffle block manager.</span></span><br><span class="line">    <span class="keyword">if</span> (shuffle != <span class="literal">null</span> &amp;&amp; buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      shuffle.releaseWriters(buckets)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Execute the callbacks on task completion.</span></span><br><span class="line">    taskContext.executeOnCompleteCallbacks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>我已经将一些干扰代码删去。可以看到Spark在每一个Mapper中为每个Reducer创建一个bucket，并将RDD计算结果放进bucket中。需要注意的是每个bucket是一个<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ArrayBuffer</code>，也就是说Map的输出结果是会先存储在内存。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">接着Spark会将ArrayBuffer中的Map输出结果写入block manager所管理的磁盘中，这里文件的命名方式为：<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">shuffle + shuffle<em>id + “</em>“ + map partition id + “_” + shuffle partition id</code>。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">早期的shuffle write有两个比较大的问题：</p><ol style="padding: 0px; margin-right: 0px; margin-left: 25px; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><li>Map的输出必须先全部存储到内存中，然后写入磁盘。这对内存是一个非常大的开销，当内存不足以存储所有的Map output时就会出现OOM。</li><li>每一个Mapper都会产生Reducer number个shuffle文件，如果Mapper个数是1k，Reducer个数也是1k，那么就会产生1M个shuffle文件，这对于文件系统是一个非常大的负担。同时在shuffle数据量不大而shuffle文件又非常多的情况下，随机写也会严重降低IO的性能。</li></ol><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在Spark 0.8版本中，shuffle write采用了与RDD block write不同的方式，同时也为shuffle write单独创建了<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>，部分解决了0.6和0.7版本中遇到的问题。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">首先我们来看一下Spark 0.8的具体实现：<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(</span>attemptId: <span class="type">Long</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">blockManager</span> =</span> <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line">  <span class="keyword">var</span> shuffle: <span class="type">ShuffleBlocks</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> buckets: <span class="type">ShuffleWriterGroup</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Obtain all the block writers for shuffle blocks.</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">ser</span> =</span> <span class="type">SparkEnv</span>.get.serializerManager.get(dep.serializerClass)</span><br><span class="line">    shuffle = blockManager.shuffleBlockManager.forShuffle(dep.shuffleId, numOutputSplits, ser)</span><br><span class="line">    buckets = shuffle.acquireWriters(partition)</span><br><span class="line">    <span class="comment">// Write the map output to its associated buckets.</span></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- rdd.iterator(split, taskContext)) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">pair</span> =</span> elem.asInstanceOf[<span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">bucketId</span> =</span> dep.partitioner.getPartition(pair._1)</span><br><span class="line">      buckets.writers(bucketId).write(pair)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commit the writes. Get the size of each bucket block (total block size).</span></span><br><span class="line">    <span class="keyword">var</span> totalBytes = <span class="number">0</span>L</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">compressedSizes</span>:</span> <span class="type">Array</span>[<span class="type">Byte</span>] = buckets.writers.map &#123; writer:   <span class="type">BlockObjectWriter</span> =&gt;</span><br><span class="line">      writer.commit()</span><br><span class="line">      writer.close()</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">size</span> =</span> writer.size()</span><br><span class="line">      totalBytes += size</span><br><span class="line">      <span class="type">MapOutputTracker</span>.compressSize(size)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">    <span class="comment">// If there is an exception from running the task, revert the partial writes</span></span><br><span class="line">    <span class="comment">// and throw the exception upstream to Spark.</span></span><br><span class="line">    <span class="keyword">if</span> (buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      buckets.writers.foreach(_.revertPartialWrites())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Release the writers back to the shuffle block manager.</span></span><br><span class="line">    <span class="keyword">if</span> (shuffle != <span class="literal">null</span> &amp;&amp; buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      shuffle.releaseWriters(buckets)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Execute the callbacks on task completion.</span></span><br><span class="line">    taskContext.executeOnCompleteCallbacks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在这个版本中为shuffle write添加了一个新的类<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>，由<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>来分配和管理bucket。同时<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>为每一个bucket分配一个<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">DiskObjectWriter</code>，每个write handler拥有默认100KB的缓存，使用这个write handler将Map output写入文件中。可以看到现在的写入方式变为<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">buckets.writers(bucketId).write(pair)</code>，也就是说Map output的key-value pair是逐个写入到磁盘而不是预先把所有数据存储在内存中在整体flush到磁盘中去。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>的代码如下所示：<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShuffleBlockManager</span>(</span>blockManager: <span class="type">BlockManager</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forShuffle</span>(</span>shuffleId: <span class="type">Int</span>, numBuckets: <span class="type">Int</span>, serializer: <span class="type">Serializer</span>): <span class="type">ShuffleBlocks</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ShuffleBlocks</span> &#123;</span><br><span class="line">      <span class="comment">// Get a group of writers for a map task.</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">acquireWriters</span>(</span>mapId: <span class="type">Int</span>): <span class="type">ShuffleWriterGroup</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">val</span> <span class="title">bufferSize</span> =</span> <span class="type">System</span>.getProperty(<span class="string">"spark.shuffle.file.buffer.kb"</span>, <span class="string">"100"</span>).toInt * <span class="number">1024</span></span><br><span class="line">        <span class="function"><span class="keyword">val</span> <span class="title">writers</span> =</span> <span class="type">Array</span>.tabulate[<span class="type">BlockObjectWriter</span>](numBuckets) &#123; bucketId =&gt;</span><br><span class="line">          <span class="function"><span class="keyword">val</span> <span class="title">blockId</span> =</span> <span class="type">ShuffleBlockManager</span>.blockId(shuffleId, bucketId, mapId)</span><br><span class="line">          blockManager.getDiskBlockWriter(blockId, serializer, bufferSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ShuffleWriterGroup</span>(mapId, writers)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">releaseWriters</span>(</span>group: <span class="type">ShuffleWriterGroup</span>) = &#123;</span><br><span class="line">        <span class="comment">// Nothing really to release here.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>Spark 0.8显著减少了shuffle的内存压力，现在Map output不需要先全部存储在内存中，再flush到硬盘，而是record-by-record写入到磁盘中。同时对于shuffle文件的管理也独立出新的<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>进行管理，而不是与rdd cache文件在一起了。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">但是这一版Spark 0.8的shuffle write仍然有两个大的问题没有解决：</p><ul style="padding: 0px; margin-right: 0px; margin-left: 25px; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><li>首先依旧是shuffle文件过多的问题，shuffle文件过多一是会造成文件系统的压力过大，二是会降低IO的吞吐量。</li><li>其次虽然Map output数据不再需要预先在内存中evaluate显著减少了内存压力，但是新引入的<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">DiskObjectWriter</code>所带来的buffer开销也是一个不容小视的内存开销。假定我们有1k个Mapper和1k个Reducer，那么就会有1M个bucket，于此同时就会有1M个write handler，而每一个write handler默认需要100KB内存，那么总共需要100GB的内存。这样的话仅仅是buffer就需要这么多的内存，内存的开销是惊人的。当然实际情况下这1k个Mapper是分时运行的话，所需的内存就只有<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">cores <em> reducer numbers </em> 100KB</code>大小了。但是reducer数量很多的话，这个buffer的内存开销也是蛮厉害的。</li></ul><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">为了解决shuffle文件过多的情况，Spark 0.8.1引入了新的shuffle consolidation，以期显著减少shuffle文件的数量。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">首先我们以图例来介绍一下shuffle consolidation的原理。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="spark shuffle  consolidation process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle-consolidate.png" width="640" style="max-width: 100%; height: auto;"></p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">假定该job有4个Mapper和4个Reducer，有2个core，也就是能并行运行两个task。我们可以算出Spark的shuffle write共需要16个bucket，也就有了16个write handler。在之前的Spark版本中，每一个bucket对应的是一个文件，因此在这里会产生16个shuffle文件。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">而在shuffle consolidation中每一个bucket并非对应一个文件，而是对应文件中的一个segment，同时shuffle consolidation所产生的shuffle文件数量与Spark core的个数也有关系。在上面的图例中，job的4个Mapper分为两批运行，在第一批2个Mapper运行时会申请8个bucket，产生8个shuffle文件；而在第二批Mapper运行时，申请的8个bucket并不会再产生8个新的文件，而是追加写到之前的8个文件后面，这样一共就只有8个shuffle文件，而在文件内部这有16个不同的segment。因此从理论上讲shuffle consolidation所产生的shuffle文件数量为<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-4-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-12" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.396em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 2.801em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.098em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-13" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-14" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">C<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span><span class="mo" id="MathJax-Span-15" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Main;">×</span><span class="mi" id="MathJax-Span-16" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>，其中<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-5-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-17" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.955em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.777em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.098em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-18" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-19" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">C<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>是Spark集群的core number，<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-6-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-20" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.955em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.777em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-21" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-22" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>是Reducer的个数。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">需要注意的是当 <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-7-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-23" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.872em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.217em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.098em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-24" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-25" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">M<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span><span class="mo" id="MathJax-Span-26" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.301em; margin: 0px; vertical-align: 0px; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-27" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.301em; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">C<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>时shuffle consolidation所产生的文件数和之前的实现是一样的。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">Shuffle consolidation显著减少了shuffle文件的数量，解决了之前版本一个比较严重的问题，但是writer handler的buffer开销过大依然没有减少，若要减少writer handler的buffer开销，我们只能减少Reducer的数量，但是这又会引入新的问题，下文将会有详细介绍。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">讲完了shuffle write的进化史，接下来要讲一下shuffle fetch了，同时还要讲一下Spark的aggregator，这一块对于Spark实际应用的性能至关重要。</p><h3 id="shuffle_fetch_and_aggregator" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 24.5px;">Shuffle Fetch and Aggregator</h3><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">Shuffle write写出去的数据要被Reducer使用，就需要shuffle fetcher将所需的数据fetch过来，这里的fetch包括本地和远端，因为shuffle数据有可能一部分是存储在本地的。Spark对shuffle fetcher实现了两套不同的框架：NIO通过socket连接去fetch数据；OIO通过netty server去fetch数据。分别对应的类是<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>和<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">NettyBlockFetcherIterator</code>。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在Spark 0.7和更早的版本中，只支持<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>，而<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>在shuffle数据量比较大的情况下performance始终不是很好，无法充分利用网络带宽，为了解决这个问题，添加了新的shuffle fetcher来试图取得更好的性能。对于早期shuffle性能的评测可以参看<a href="https://groups.google.com/forum/#!msg/shark-users/IHOb2u5HXSk/huTWyosI1n4J" style="color: rgb(0, 136, 204);" target="_blank" rel="external">Spark usergroup</a>。当然现在<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>的性能也已经好了很多，使用的时候可以对这两种实现都进行测试比较。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">接下来说一下aggregator。我们都知道在Hadoop MapReduce的shuffle过程中，shuffle fetch过来的数据会进行merge sort，使得相同key下的不同value按序归并到一起供Reducer使用，这个过程可以参看下图：</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="mapreduce shuffle process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-shuffle.png" width="640" style="max-width: 100%; height: auto;"></p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">所有的merge sort都是在磁盘上进行的，有效地控制了内存的使用，但是代价是更多的磁盘IO。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">那么Spark是否也有merge sort呢，还是以别的方式实现，下面我们就细细说明。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">首先虽然Spark属于MapReduce体系，但是对传统的MapReduce算法进行了一定的改变。Spark假定在大多数用户的case中，shuffle数据的sort不是必须的，比如word count，强制地进行排序只会使性能变差，因此Spark并不在Reducer端做merge sort。既然没有merge sort那Spark是如何进行reduce的呢？这就要说到aggregator了。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">aggregator本质上是一个hashmap，它是以map output的key为key，以任意所要combine的类型为value的hashmap。当我们在做word count reduce计算count值的时候，它会将shuffle fetch到的每一个key-value pair更新或是插入到hashmap中(若在hashmap中没有查找到，则插入其中；若查找到则更新value值)。这样就不需要预先把所有的key-value进行merge sort，而是来一个处理一个，省下了外部排序这一步骤。但同时需要注意的是reducer的内存必须足以存放这个partition的所有key和count值，因此对内存有一定的要求。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在上面word count的例子中，因为value会不断地更新，而不需要将其全部记录在内存中，因此内存的使用还是比较少的。考虑一下如果是group by key这样的操作，Reducer需要得到key对应的所有value。在Hadoop MapReduce中，由于有了merge sort，因此给予Reducer的数据已经是group by key了，而Spark没有这一步，因此需要将key和对应的value全部存放在hashmap中，并将value合并成一个array。可以想象为了能够存放所有数据，用户必须确保每一个partition足够小到内存能够容纳，这对于内存是一个非常严峻的考验。因此Spark文档中建议用户涉及到这类操作的时候尽量增加partition，也就是增加Mapper和Reducer的数量。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">增加Mapper和Reducer的数量固然可以减小partition的大小，使得内存可以容纳这个partition。但是我们在shuffle write中提到，bucket和对应于bucket的write handler是由Mapper和Reducer的数量决定的，task越多，bucket就会增加的更多，由此带来write handler所需的buffer也会更多。在一方面我们为了减少内存的使用采取了增加task数量的策略，另一方面task数量增多又会带来buffer开销更大的问题，因此陷入了内存使用的两难境地。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">为了减少内存的使用，只能将aggregator的操作从内存移到磁盘上进行，Spark社区也意识到了Spark在处理数据规模远远大于内存大小时所带来的问题。因此<a href="https://github.com/apache/incubator-spark/pull/303" style="color: rgb(0, 136, 204);" target="_blank" rel="external">PR303</a>提供了外部排序的实现方案，相信在Spark 0.9 release的时候，这个patch应该能merge进去，到时候内存的使用量可以显著地减少。</p><h2 id="end" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 31.5px;">End</h2><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">本文详细地介绍了Spark的shuffle实现是如何进化的，以及遇到问题解决问题的过程。shuffle作为Spark程序中很重要的一个环节，直接影响了Spark程序的性能，现如今的Spark版本虽然shuffle实现还存在着种种问题，但是相比于早期版本，已经有了很大的进步。开源代码就是如此不停地迭代推进，随着Spark的普及程度越来越高，贡献的人越来越多，相信后续的版本会有更大的提升。</p>]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/" target="_blank">http://jerryshao.me/archit]]>
    </summary>
    
      <category term="shuffle" scheme="http://valux.cn/tags/shuffle/"/>
    
      <category term="spark" scheme="http://valux.cn/tags/spark/"/>
    
      <category term="share" scheme="http://valux.cn/categories/share/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/share/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spark及其应用场景初探]]></title>
    <link href="http://valux.cn/2015/04/23/f3765ddf5d8853f3/"/>
    <id>http://valux.cn/2015/04/23/f3765ddf5d8853f3/</id>
    <published>2015-04-22T16:04:31.000Z</published>
    <updated>2015-07-31T19:47:39.489Z</updated>
    <content type="html"><![CDATA[<p>最近老大让用<code>Spark</code>做一个ETL项目，搭建了一套只有三个结点Standalone模式的Spark集群做测试，基础数据量大概8000W左右。看了官方文档，Spark确实在Map-Reduce上提升了很多，可是官方明确提出了在<code>Interactive Data</code> 方面性能提升最大。但是做ETL的数据之间是平行结构，没有任何交互，数据处理完直接就推送走了，也不用做任何缓存，因此完全体现不出来Spark的优势。具体可以用下面这个例子来说，</p>
<blockquote>
<p>假设Hadoop集群中有一个文件，每行有一个随机数，我们现在需要计算这些数据的方差 (假设中间过程不会溢出)<br><code>方差公式</code> <img src="http://content.errdev.com/media/image/20150423234917577.jpg" alt="方差公式">  </p>
</blockquote>
<p>那么计算过程可以表示为<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = sc.textFile(<span class="string">"hdfs://dataset.txt"</span>)</span><br><span class="line">file.persist()</span><br><span class="line"><span class="keyword">var</span> length = file.count()</span><br><span class="line"><span class="keyword">var</span> sum = file.reduce((a, b) =&gt; a+b)</span><br><span class="line"><span class="keyword">var</span> sqsum = file.map(line =&gt; line * line).reduce( (a,b) =&gt; a+b )</span><br><span class="line"><span class="keyword">var</span> variance = sqsum / length / - sum * sum / length / length</span><br></pre></td></tr></table></figure></p>
<p>这个过程很简单，但是可以体现出这个交互的过程。file 是一个<code>RDD</code>，这个例子有且仅有一个RDD。Spark中对RDD的操作有两类<code>Transformation</code>和<code>Action</code>，<code>Transformation</code>是一个延时的过程，只有当具体的<code>Action</code>应用时，才会对具体的数据做运算。Spark的容错机制也正是根据了<code>Transformation</code>对RDD进行了<code>Lineage</code>的推算，即使在某个结点在某种状态下数据丢失，也可以根据记录的<code>Transformations</code>推算出当前请求的RDD数据集。<br>扯远了，还是看上面这个例子，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = sc.textFile(<span class="string">"hdfs://dataset.txt"</span>)</span><br></pre></td></tr></table></figure>
<p>这里不会立即去集群读取这个文件，而是会延迟到后面具体的<code>Action</code>例如<code>count()</code>时，才会遍历文件。获取所有数据的长度，需要读取一次dataset.txt这个文件，集群中遍历这个文件虽然很快，但是下一次在求和与平方和时，又需要遍历两次次这个文件，那么差别就来了</p>
<blockquote>
<p>map - reduce 程序是需要三次IO，集群需要从HDFS上三次获取这个文件进行遍历<br>Spark 能够将 file 这个RDD缓存在集群的共享内存中，那么在处理时实际上只有一次IO，另外两次遍历直接从内存读取  </p>
</blockquote>
<p>这个例子很简单，那么我们在做<code>数据挖掘</code>或者<code>迭代运算</code>时，这样的交互行为会很多，需要缓存的中间数据集也会有很多，那么在map-reduce过程中，由于没有内存缓存的机制，只有将中间状态缓存到HDFS中，而Spark通过缓存避免了这些IO，效率就提升了。</p>
<h4 id="参考文档">参考文档</h4><blockquote>
<p>[1] <a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="external">programming-guide</a><br>[2] <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-12.pdf" target="_blank" rel="external">An Architecture for Fast and General Data Processing on Large Clusters</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近老大让用<code>Spark</code>做一个ETL项目，搭建了一套只有三个结点Standalone模式的Spark集群做测试，基础数据量大概8000W左右。看了官方文档，Spark确实在Map-Reduce上提升了很多，可是官方明确提出了在<code>Intera]]>
    </summary>
    
      <category term="spark" scheme="http://valux.cn/tags/spark/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/essay/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CLR Inside Out - Large Object Heap Uncovered]]></title>
    <link href="http://valux.cn/2015/04/22/d7aed8c4df42494e/"/>
    <id>http://valux.cn/2015/04/22/d7aed8c4df42494e/</id>
    <published>2015-04-21T16:04:31.000Z</published>
    <updated>2015-07-31T19:47:21.157Z</updated>
    <content type="html"><![CDATA[<div id="main" style="border: 0px; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; margin: 0px; outline: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 16.0016002655029px;"><div class="ArticleNormalPara" id="id0070001" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">原文链接：<a href="https://msdn.microsoft.com/en-us/magazine/cc534993.aspx" target="_blank">https://msdn.microsoft.com/en-us/magazine/cc534993.aspx</a>    作者：<strong style="line-height: 16.0016002655029px; border: 0px; margin: 0px; outline: 0px; padding: 0px; color: rgb(38, 37, 42); font-size: 14px;">Maoni Stephens</strong><a href="https://msdn.microsoft.com/en-us/magazine/cc534993.aspx" target="_blank"></a></div><div class="ArticleNormalPara" id="id0070001" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">The CLR garbage collector (GC) divides objects into small and large categories. When an object is large, some attributes associated with it become more significant than if the object is small. For instance, compacting it—copying the memory elsewhere on the heap—is expensive. In this month’s column I am going to look at the large object heap in depth. I will talk about what qualifies an object as a large object, how these large objects are collected, and what kind of performance implications large objects impose.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070002" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">The Large Object Heap and the GC</div><div class="ArticleNormalPara" id="id0070003" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">In the Microsoft<span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; vertical-align: text-top;">®</span> .NET Framework 1.1 and 2.0, if an object is greater than or equal to 85,000 bytes it’s considered a large object. This number was determined as a result of performance tuning. When an object allocation request comes in and meets that size threshold, it will be allocated on the large object heap. What does this mean exactly? To understand this, it may be beneficial to explain some fundamentals about the .NET garbage collector.</div><div class="ArticleNormalPara" id="id0070004" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">As many of you are aware, the .NET garbage collector is a generational collector. It has three generations: generation 0, generation 1, and generation 2. The reason for this is so that in a well-tuned application, you can expect most objects to die in generation 0. For example, in a server app, the allocations associated with each request should die after the request is finished. The in-flight allocation requests will make it into generation 1 and die there. Essentially, generation 1 acts as a buffer between young object areas and long-lived object areas.</div><div class="ArticleNormalPara" id="id0070005" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">From a generation point of view, large objects belong to generation 2 because they are collected only when there is a generation 2 collection. When a generation is collected, all younger generations are also collected. So for example, when a generation 1 garbage collection happens, both generation 1 and 0 are collected. And when a generation 2 garbage collection happens, the whole heap is collected. For this reason, a generation 2 garbage collection is also known as a full garbage collection. In this column I will use the term generation 2 garbage collection instead of full garbage collection, but they are interchangeable.</div><div class="ArticleNormalPara" id="id0070006" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Generations are the logical view of the garbage collector heap. Physically, objects live on managed heap segments. A managed heap segment is a chunk of memory that the garbage collector reserves from the OS (via calling VirtualAlloc) on behalf of managed code. When the CLR is loaded, two initial heap segments are allocated—one for small objects and one for large objects, which I will refer to as the small object heap (SOH) and the large object heap (LOH), respectively.</div><div class="ArticleNormalPara" id="id0070007" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Allocation requests are then satisfied by putting managed objects on one of these managed heap segments. If the object is less than 85,000 bytes, it will be put on a SOH segment; otherwise it’ll be on a LOH segment. Segments are committed (in smaller chunks) as more and more objects are allocated onto them.</div><div class="ArticleNormalPara" id="id0070008" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">For the SOH, objects that survive a garbage collection are promoted to the next generation; so objects that survive a generation 0 collection will be considered generation 1 objects, and so on. Objects that survive the oldest generation, however, will still be considered in the oldest generation. In other words, survivors from generation 2 will be generation 2 objects; and survivors from LOH will be LOH objects (collected with generation 2). User code can only allocate in generation 0 (small objects) or LOH (large objects). Only the garbage collector can “allocate” objects in generation 1 (by promoting survivors from generation 0) and generation 2 (by promoting survivors from generations 1 and 2).</div><div class="ArticleNormalPara" id="id0070009" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">When a garbage collection is triggered, the garbage collector traces through the live objects and compacts them. For LOH, though, because compaction is expensive the CLR team chose to sweep them, making a free list out of dead objects that can be reused later to satisfy large object allocation requests. Adjacent dead objects are made into one free object.</div><div class="ArticleNormalPara" id="id0070010" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">An important thing to keep in mind is that even though today we don’t compact LOH, we might in the future. So if you allocate large objects and want to make sure they don’t move, you should still pin them.</div><div class="ArticleNormalPara" id="id0070011" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Note that the figures shown here are only for illustration purposes. I used very few objects, just to show what happens on the heap. In reality there are many more objects there.</div><div class="ArticleNormalPara" id="id0070012" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Figure 1 illustrates a scenario where I form generation 1 after the first generation 0 GC where Obj1 and Obj3 are dead; and I form generation 2 after the first generation 1 GC where Obj2 and Obj5 are dead.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig01_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 1 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">SOH Allocations and Garbage Collections</strong></div></div><div class="ArticleNormalPara" id="id0070013" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Figure 2 illustrates that after a generation 2 garbage collection in which you saw that Obj1 and Obj2 were dead, I formed one free space out of the memory that used to be occupied by Obj1 and Obj2, which then was used to satisfy the allocation request for Obj4. The space after the last object Obj3 until the end of the segment can still be used to satisfy further allocation requests.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig02_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 2 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">LOH Allocations and Garbage Collections</strong></div></div><div class="ArticleNormalPara" id="id0070014" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">If I don’t have enough free space to accommodate the large object allocation requests, I will first attempt to acquire more segments from the OS. If that fails, then I will trigger a generation 2 garbage collection in hope of freeing up some space.</div><div class="ArticleNormalPara" id="id0070015" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">During a generation 2 garbage collection, I take the opportunity to release segments that have no live objects on them back to the OS (by calling VirtualFree). Memory from the last live object to the end of the segment is decommitted. And the free spaces remain committed though they are reset, meaning the OS doesn’t need to write data in them back to disk. <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 3</strong> illustrates a scenario in which I release a segment back to the OS (segment 2) and decommit more space on the remaining segments. If I need to use the decommitted space at the end of the segment to satisfy new large object allocation requests, I will commit the memory again.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig03_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 3 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Dead Segments Released on LOH during Garbage Collection</strong></div></div><div class="ArticleNormalPara" id="id0070016" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">For an explanation on commit/decommit, please see the MSDN<span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; vertical-align: text-top;">®</span> documentation on VirtualAlloc at<a id="ctl00_MTContentSelector1_mainContentContainer_ctl06" href="http://go.microsoft.com/fwlink/?LinkId=116041" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116041</a>.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070017" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">When a Large Object Gets Collected</div><div class="ArticleNormalPara" id="id0070018" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">To determine when a large object is collected, let’s first talk about when a garbage collection happens in general. A garbage collection occurs if one of the following conditions happens:</div><div class="ArticleNormalPara" id="id0070019" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Allocation Exceeds the Generation 0 or Large Object Threshold Most GCs happen because of allocations on the managed heap (this is the most typical case).</div><div class="ArticleNormalPara" id="id0070020" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">System.GC.Collect Is Called When someone calls GC.Collect on generation 2 (by passing either no arguments to GC.Collect or passing GC.MaxGeneration as an argument), the LOH will get collected right away along with the rest of the managed heap.</div><div class="ArticleNormalPara" id="id0070021" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">System Is in Low Memory Situation This happens when I receive the high memory notification from the OS. If I think doing a generation 2 GC will be productive, I will trigger one.</div><div class="ArticleNormalPara" id="id0070022" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">The threshold is a property of each generation. When you allocate objects into a generation, you increase the amount of memory in that generation and get closer to the generation’s threshold. And when the threshold is exceeded for a generation, a garbage collection is triggered on that generation. So when you allocate small or large objects, you consume generation 0’s and LOH’s respective thresholds. And when the garbage collector allocates into generation 1 and 2, it consumes generation 1 thresholds. These thresholds are dynamically tuned as the program runs.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070023" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">LOH Performance Implications</div><div class="ArticleNormalPara" id="id0070024" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Let’s look at allocation costs. The CLR makes the guarantee that the memory for every new object I give out is cleared. This means the allocation cost of a large object is completely dominated by memory clearing (unless it triggers a garbage collection). If it takes two cycles to clear 1 byte, it means it takes 170,000 cycles to clear the smallest large object. It’s not uncommon for people to allocate large objects that are a bit too large. For a 16MB object on a 2GHz machine, it will take approximately 16ms to clear the memory. That’s a rather large cost.</div><div class="ArticleNormalPara" id="id0070025" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Now let’s see about collection costs. As mentioned earlier, LOH and generation 2 are collected together. If either one’s threshold is exceeded, a generation 2 collection will be triggered. If a generation 2 was triggered because of the LOH, generation 2 itself won’t necessarily get much smaller after the garbage collection. Now, if there’s not much data on generation 2, this is not a problem. But if generation 2 is big, it could cause performance problems if many generation 2 garbage collections are triggered. If many large objects are allocated on a very temporary basis and you have a big SOH, you could be spending too much time running garbage collections; not to mention that the allocation cost can really add up if you keep allocating and letting really large objects go.</div><div class="ArticleNormalPara" id="id0070026" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Very large objects on the LOH are usually arrays (it’s very rare to have an instance object that’s really, really large). If the elements of an array are reference-rich, the cost is high. If the element doesn’t contain any references, I wouldn’t need to go through the array at all. For example, if you use an array to store nodes in a binary tree, one way to implement it is to refer to a node’s right and left node by the actual nodes:</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl07" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></span></p><div class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl07_" style="border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 611.1875px;"><div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl07_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">class Node<br>{<br>    Data d;<br>    Node left;<br>    Node right;<br>};<br><br>Node[] binary<em>tr = new Node [num_nodes];<br></em></pre></div></div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"></p><div class="ArticleNormalPara" id="id0070035" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">If num_nodes is a large number, it means you will need to go through at least two references per element. An alternative approach is to store the index of the right and the left node:</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl08" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></span></p>&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl08“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 611.1875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl08_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">class Node<br>{<br>    Data d;<br>    uint left<em>index;<br>    uint right_index;<br>};<br></em></pre></div></div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"></p><div class="ArticleNormalPara" id="id0070042" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">This way, instead of referring to the left node’s data as left.d, you would refer to it as binary_tr[left_index].d. And the garbage collector wouldn’t need to look at any references for left and right node.</div><div class="ArticleNormalPara" id="id0070043" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Out of the three reasons for a collection, the first two are usually more dominant than the third. Therefore, it’s best if you can allocate a pool of large objects and reuse them instead of allocating temporary ones. Yun Jin has a good example of such a buffer pool in his blog entry (<a id="ctl00_MTContentSelector1_mainContentContainer_ctl09" href="http://go.microsoft.com/fwlink/?LinkId=115870" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=115870</a>). Of course, you would want to make the buffer size larger.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070044" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">Collecting Performance Data for the LOH</div><div class="ArticleNormalPara" id="id0070045" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">There are a few ways to collect performance data that’s relevant to the LOH. But before I explain them, let’s talk about why you would want to do it.</div><div class="ArticleNormalPara" id="id0070046" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Before you start collecting performance data for a specific area, hopefully you have already found evidence that you should be looking at this area or you have exhausted other areas that you know of and didn’t find any problems that could explain a performance problem you are observing.</div><div class="ArticleNormalPara" id="id0070047" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">I would recommend reading a blog entry of mine for more explanation (see <a id="ctl00_MTContentSelector1_mainContentContainer_ctl10" href="http://go.microsoft.com/fwlink/?LinkId=116467" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116467</a>). There I talk about the fundamentals of memory and CPU. Additionally, the November 2006 installment of CLR Inside Out on investigating memory issues talks about steps involved in diagnosing performance problems in a managed process that may be related to managed heap (see<a id="ctl00_MTContentSelector1_mainContentContainer_ctl11" href="http://msdn2.microsoft.com/magazine/cc163528" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">msdn2.microsoft.com/magazine/cc163528</a>).</div><div class="ArticleNormalPara" id="id0070048" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">.NET CLR Memory Performance counters are usually a good first step in investigating performance issues. The counters that are relevant to the LOH are the number of generation 2 collections and the large object heap size. The number of generation 2 collections displays the number of times generation 2 garbage collections have occurred since the process started. The counter is incremented at the end of a generation 2 garbage collection (also called a full garbage collection). This counter displays the last observed value.</div><div class="ArticleNormalPara" id="id0070049" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Large object heap size is the current size in bytes, including the free space, of the Large Object Heap. This counter is updated at the end of a garbage collection, not at each allocation.</div><div class="ArticleNormalPara" id="id0070050" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">A common way to look at performance counters is via Perfor­mance Monitor (PerfMon.exe). Use “Add Counters” to add the interesting counter for processes that you care about, as you can see in <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 4</strong>.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig04_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 4 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Adding Counters in Performance Monitor</strong></div></div><div class="ArticleNormalPara" id="id0070051" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">You can save the performance counter data to a log file in Perf­Mon. Performance counters can also be queried programmatically. Many people collect them this way as part of their routine testing process. When you spot counters with values that are out of the ordinary, you can then use other means to get more details to help with the investigation.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070052" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">Using a Debugger</div><div class="ArticleNormalPara" id="id0070053" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Before I begin, you should note that the debugging commands I’ll mention in this section are applicable to the Windows<span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; vertical-align: text-top;">®</span> Debuggers. If you need to look at which objects are actually on the LOH, you can use the SoS debugger extension provided by the CLR, which is explained in the November 2006 installment I mentioned previously. An example output of analyzing the LOH is shown in <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 5</strong>.</div><div class="ArticleNormalPara" id="id0070054" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">The bold sections of <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 5</strong> say that the LOH heap size is (16,754,224 + 16,699,288 + 16,284,504 =) 49,738,016 bytes. And between address 023e1000 and 033db630, there are 8,008,736 bytes occupied by Sys­tem.Ob­ject[] objects; 6,663,696 occupied by System.Byte[] objects; and 2,081,792 occupied by free space.</div><div class="figmargin" id="id016" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><div class="MTPS_CollapsibleRegion" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><div class="CollapseRegionLink" style="border: 0px; font-weight: bold; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; cursor: pointer; color: rgb(0, 0, 0);"><img class="LibC_o" src="http://i.msdn.microsoft.com/Global/Images/clear.gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; width: 16px; height: 16px; background: url(https://msdn.microsoft.com/global/Images/LibC.gif) 0px 0px;">  Figure 5 LOH Output</div><div class="MTPS_CollapsibleSection" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 0px 10px; clear: both;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl28_ctl00_ctl00" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl28_ctl00_ctl00“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 601.296875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl28_ctl00_ctl00_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">0:003&gt; .loadby sos mscorwks﻿<br>0:003&gt; !eeheap -gc<br>Number of GC Heaps: 1<br>generation 0 starts at 0x013e35ec<br>generation 1 starts at 0x013e1b6c<br>generation 2 starts at 0x013e1000<br>ephemeral segment allocation context: none<br> segment    begin allocated     size<br>0018f2d0 790d5588  790f4b38 0x0001f5b0(128432)<br>013e0000 013e1000  013e35f8 0x000025f8(9720)<strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><br>Large object heap starts at 0x023e1000<br> segment    begin allocated     size<br>023e0000 023e1000  033db630 0x00ffa630(16754224)<br>033e0000 033e1000  043cdf98 0x00fecf98(16699288)<br>043e0000 043e1000  05368b58 0x00f87b58(16284504)</strong><br>Total Size  0x2f90cc8(49876168)<br>———————————————<br>GC Heap Size  0x2f90cc8(49876168)<br><strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">0:003&gt; !dumpheap -stat 023e1000  033db630<br>total 133 objects<br>Statistics:<br>      MT    Count    TotalSize Class Name<br>001521d0       66      2081792      Free<br>7912273c       63      6663696 System.Byte[]<br>7912254c        4      8008736 System.Object[]<br>Total 133 objects</strong></pre></div></span></div></div></span></div><div class="ArticleNormalPara" id="id0070055" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Sometimes you’ll see that the total size of the LOH is less than 85,000 bytes. Why is this? It’s because the runtime itself actually uses LOH to allocate some objects that are smaller than a large object.</div><div class="ArticleNormalPara" id="id0070056" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Since the LOH is not compacted, sometimes people suspect that the LOH is a source of fragmentation. You really need to first clarify what fragmentation means. There’s fragmentation of the managed heap, which is indicated by the amount of free space between managed objects (in other words, what you see when you do !dumpheap –type Free in SoS); there’s also fragmentation of the virtual memory (VM) address space, which is the memory marked as <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">MEM<em>FREE</em></strong> and which you can see by using various debugger commands in windbg (see <a id="ctl00_MTContentSelector1_mainContentContainer_ctl15" href="http://go.microsoft.com/fwlink/?LinkId=116470" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116470</a>). <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 6</strong> shows the fragmentation in the virtual memory space (note the bold text in the figure).</div><div class="figmargin" id="id018" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><div class="MTPS_CollapsibleRegion" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><div class="CollapseRegionLink" style="border: 0px; font-weight: bold; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; cursor: pointer; color: rgb(0, 0, 0);"><img class="LibC_o" src="http://i.msdn.microsoft.com/Global/Images/clear.gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; width: 16px; height: 16px; background: url(https://msdn.microsoft.com/global/Images/LibC.gif) 0px 0px;">  Figure 6 VM Space Fragmentation</div><div class="MTPS_CollapsibleSection" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 0px 10px; clear: both;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl30_ctl00_ctl00" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl30_ctl00_ctl00“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 601.296875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl30_ctl00_ctl00_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">0:000&gt; !address﻿<br>    00000000 : 00000000 - 00010000<br>                    Type     00000000<br>                    Protect  00000001 PAGE<em>NOACCESS<br>                    State    00010000 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">MEM_FREE</strong><br>                    Usage    RegionUsageFree<br>    00010000 : 00010000 - 00002000<br>                    Type     00020000 MEM_PRIVATE<br>                    Protect  00000004 PAGE_READWRITE<br>                    State    00001000 MEM_COMMIT<br>                    Usage    RegionUsageEnvironmentBlock<br>    00012000 : 00012000 - 0000e000<br>                    Type     00000000<br>                    Protect  00000001 PAGE_NOACCESS<br>                    State    00010000 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">MEM_FREE</strong><br>                    Usage    RegionUsageFree<br>… [omitted]<br>—————————— Usage SUMMARY —————————————<br>    TotSize (      KB)   Pct(Tots) Pct(Busy)   Usage<br>     701000 (    7172) : 00.34%    20.69%    : RegionUsageIsVAD<br><strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">   7de15000 ( 2062420) : 98.35%    00.00%    : RegionUsageFree</strong><br>    1452000 (   20808) : 00.99%    60.02%    : RegionUsageImage<br>     300000 (    3072) : 00.15%    08.86%    : RegionUsageStack<br>       3000 (      12) : 00.00%    00.03%    : RegionUsageTeb<br>     381000 (    3588) : 00.17%    10.35%    : RegionUsageHeap<br>          0 (       0) : 00.00%    00.00%    : RegionUsagePageHeap<br>       1000 (       4) : 00.00%    00.01%    : RegionUsagePeb<br>       1000 (       4) : 00.00%    00.01%    : RegionUsageProcessParametrs<br>       2000 (       8) : 00.00%    00.02%    : RegionUsageEnvironmentBlock<br>       Tot: 7fff0000 (2097088 KB) Busy: 021db000 (34668 KB)<br><br>—————————— Type SUMMARY —————————————<br>    TotSize (      KB)   Pct(Tots)  Usage<br>   <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">7de15000 ( 2062420) : 98.35%   : <free></free></strong><br>    1452000 (   20808) : 00.99%   : MEM_IMAGE<br>     69f000 (    6780) : 00.32%   : MEM_MAPPED<br>     6ea000 (    7080) : 00.34%   : MEM_PRIVATE<br><br>—————————— State SUMMARY —————————————<br>    TotSize (      KB)   Pct(Tots)  Usage<br>    1a58000 (   26976) : 01.29%   : MEM_COMMIT<br>   7de15000 ( 2062420) : 98.35%   : MEM_FREE<br>     783000 (    7692) : 00.37%   : MEM_RESERVE<br><strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Largest free region: Base 01432000 - Size 707ee000 (1843128 KB)</strong></em></pre></div></span></div></div></span></div><div class="ArticleNormalPara" id="id0070057" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">As mentioned earlier, fragmentation on the managed heap is used for allocation requests. It’s more common to see virtual memory fragmentation caused by temporary large objects that require frequent garbage collection to acquire new managed heap segments from the OS and release empty ones back to the OS.</div><div class="ArticleNormalPara" id="id0070058" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">To verify whether the LOH is causing VM fragmentation, you can set a breakpoint on VirtualAlloc and VirtualFree and see who calls them. For example, if I want to see who tried to allocate VM chunks from the OS that are larger than 8MB, I can set a breakpoint like this:</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl18" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></span></p>&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl18“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 611.1875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl18_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">bp kernel32!virtualalloc “j (dwo(@esp+8)&gt;800000) ‘kb’;’g’”</pre></div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"></p><div class="ArticleNormalPara" id="id0070060" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">This breaks into the debugger and shows me the callstack if Virtual­Alloc is called with the allocation size greater than 8MB (0x800000) and doesn’t break into the bugger otherwise.</div><div class="ArticleNormalPara" id="id0070061" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">In CLR 2.0 we added a feature called VM Hoarding that may be applicable if you are in a situation where segments (including those for both the large and small object heaps) are frequently acquired and released. To specify VM Hoarding, you specify a startup flag called STARTUP_HOARD_GC_VM via the hosting API (see <a id="ctl00_MTContentSelector1_mainContentContainer_ctl19" href="http://go.microsoft.com/fwlink/?LinkId=116471" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116471</a>). When you specify this, instead of releasing empty segments back to the OS, the memory on these segments is simply decommitted and put on a standby list. The segments on the standby list will be used later to satisfy new segment requests. So next time I need a new segment, I’ll use one from this standby list if I can find one that’s big enough.</div><div class="ArticleNormalPara" id="id0070062" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Note that this isn’t done for the segments that are too large. This feature is also useful for applications that want to hold onto the segments that they’ve already acquired, like some server apps that seek to avoid fragmentation of the VM space as much as they can so that they don’t cause out-of-memory errors. And they can do this since they are usually the dominating apps on the machine. I strongly recommend you carefully test your application when you use this feature and make sure it has a fairly stable memory usage.</div><div class="ArticleNormalPara" id="id0070063" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Large objects are expensive. The allocation cost is high because the CLR needs to clear the memory for a newly allocated large object to satisfy the CLR guarantee that memory for all newly allocated objects is cleared. The LOH is collected with the rest of the heap, so carefully analyze how that impacts your app’s performance. The recommendation is to reuse large objects if possible to avoid fragmentation on the managed heap and the VM space.</div><div class="ArticleNormalPara" id="id0070064" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Finally, as of right now, the LOH is not compacted as a part of collection, but that is an implementation detail that should not be relied on. So to make sure something is not moved by the GC, always pin it. Now take your newfound LOH knowledge and go take control of the heap.</div><div><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div id="main" style="border: 0px; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; margin: 0px; outline: 0p]]>
    </summary>
    
      <category term="clr" scheme="http://valux.cn/tags/clr/"/>
    
      <category term="gc" scheme="http://valux.cn/tags/gc/"/>
    
      <category term="heap" scheme="http://valux.cn/tags/heap/"/>
    
      <category term="share" scheme="http://valux.cn/categories/share/"/>
    
      <category term="csharp" scheme="http://valux.cn/categories/share/csharp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打造简洁的markdown编辑器]]></title>
    <link href="http://valux.cn/2015/04/20/4c6208c359793ebc/"/>
    <id>http://valux.cn/2015/04/20/4c6208c359793ebc/</id>
    <published>2015-04-19T16:04:31.000Z</published>
    <updated>2015-07-31T19:49:40.868Z</updated>
    <content type="html"><![CDATA[<p>每<code>Markdown</code>以其简洁的<a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="external"><code>语法</code></a>赢得了广大程序猿的喜爱，搜了一下<code>github</code>上相关的web编辑器，星星比较多的</p>
<blockquote>
<p><a href="https://stackedit.io/" target="_blank" rel="external">Stackedit</a><br><a href="http://dillinger.io/" target="_blank" rel="external">dillinger</a><br><a href="https://github.com/OscarGodson/EpicEditor" target="_blank" rel="external">EpicEditor</a></p>
</blockquote>
<p>前面两个是集成的编辑器，提供很多的功能，可是我想找一个能嵌入到当前web应用的，替换当前的<code>WYSIWYG</code>编辑器。只有后面一个是嵌入式的编辑器，但是试了一下提供的编辑功能随便不错，提供的API太少了，很多地方不能自定义。</p>
<p>还是自己来一发算了，这个也非常简单，因为所有的组件都有现成的，只需要简单拼凑一下。</p>
<blockquote>
<p><code>bootstrap</code> 用来做简单的布局<br><a href="https://github.com/chjj/marked" target="_blank" rel="external"><code>marked</code></a> markdown 的解析器，js版本<br><a href="https://github.com/knsv/mermaid" target="_blank" rel="external"><code>mermaid</code></a> markdown 的图表解析器，可以用markdown的语法画流程图<br><a href="http://codemirror.net/" target="_blank" rel="external"><code>CodeMirror</code></a> 强大的在线代码编辑器<br><a href="http://highlightjs.org" target="_blank" rel="external"><code>highlightjs</code></a> 代码高亮插件，自带丰富的主题  </p>
</blockquote>
<p>准备好了上面的插件，新建一个页面html，引入所有插件对应的css和js，<code>mermaid</code>暂时忽略。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span> <span class="attribute">style</span>=<span class="value">"margin-top: 30px;"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-lg-6"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"editor"</span> <span class="attribute">style</span>=<span class="value">"border: 1px solid #d8d8d8;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-lg-6"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"preview"</span> <span class="attribute">style</span>=<span class="value">"border: 1px solid #d8d8d8; height: 600px; padding: 5px;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在文档最后加入加入相应的js代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> editor = CodeMirror(<span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>), &#123;</span><br><span class="line">  lineNumbers: <span class="literal">true</span>,</span><br><span class="line">     mode: <span class="string">"markdown"</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">var</span> preview = <span class="built_in">document</span>.getElementById(<span class="string">"preview"</span>);</span><br><span class="line"> editor.setSize(<span class="literal">null</span>, <span class="number">600</span>);</span><br><span class="line">    editor.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    preview.innerHTML = marked(editor.getValue(), &#123;</span><br><span class="line">     highlight: <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> hljs.highlightAuto(code).value;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20150420192145464.png" alt="Markdown"></p>
<p>这样，一个简单的<code>markdown编辑器</code>就组装完了，当然要后续还会加入更多的编辑功能来扩充这个编辑器</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>每<code>Markdown</code>以其简洁的<a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="external"><code>语法</code></a>赢得了广大程序猿的喜爱，搜]]>
    </summary>
    
      <category term="markdown" scheme="http://valux.cn/tags/markdown/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="javascript" scheme="http://valux.cn/categories/essay/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop 2.6 测试环境搭建]]></title>
    <link href="http://valux.cn/2015/04/14/e716b1b6a8bada9a/"/>
    <id>http://valux.cn/2015/04/14/e716b1b6a8bada9a/</id>
    <published>2015-04-13T16:04:31.000Z</published>
    <updated>2015-07-31T19:48:01.720Z</updated>
    <content type="html"><![CDATA[<p><code>Hadoop2.6</code> 是目前Hadoop的最新版本，从下面链接获得</p>
<blockquote>
<p><a href="http://hadoop.apache.org/releases.html#Download" target="_blank" rel="external">http://hadoop.apache.org/releases.html#Download</a></p>
</blockquote>
<p>同时需要准备至少一台Linux， 这里我用了CentOS 7。虚拟机装CentOS的时候最好用桥接模式，保证后面虚拟机的集群可以互相访问。公司刚好搭的有<code>OpenStack</code>，我就懒得用虚拟机了。</p>
<h3 id="单节点模式">单节点模式</h3><p>首先解压发布包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf hadoop-<span class="number">2.6</span>.<span class="number">0</span>.tar.gz</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Hadoop2.6</code> 将所有配置都放在了 HADOOP_HOME/etc/hadoop 下面了<br>网上很多老的资料都是放在conf下的，导致之前做 Research 的时候<br>浪费了很多时间</p>
</blockquote>
<p>CentOS 默认安装了OpenJDK的，但是需要自己配置下环境变量。CentOS的<br>OpenJDK一般装在<code>/usr/java/jdk-version/</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME = /usr/java/jdk1.<span class="number">7.0</span>_55/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然导入了环境变量，但是后面我运行<code>dfs</code>的时候会提示没有设置JAVA_HOME<br>所以这里顺便把HADOOP脚本也修改了</p>
</blockquote>
<p>在<code>/HADOOP/etc/hadoop/hadoop-env.sh</code>文件前面，注释掉<code>export JAVA_HOME=${JAVA_HOME}</code>，加一行<code>export JAVA_HOME=&quot;/usr/java/jdk1.7.0_55&quot;</code>, 同样修改<code>yarn-env.sh</code>文件</p>
<p>然后需要修改<code>Hadoop</code>的配置</p>
<blockquote>
<ul>
<li>core-site.xml</li>
<li>hdfs-site.xml</li>
</ul>
</blockquote>
<p>打开 <code>core-site.xml</code> 加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://Hostname:8020<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有两个问题，<code>Hostname</code>可以配置成<code>127.0.0.1</code>，但是后面链接的时候会有各种问题，所以我直接配成了Hostname。<br>官方的文档里端口号配的是<code>9000</code>，但是其它程序连接Hadoop时一般会默认使用<code>8020</code>端口，为了后面偷懒，这里配成了<code>8020</code></p>
</blockquote>
<p>打开 <code>hdfs-site.xml</code> 加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">value</span>&gt;</span>1<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>因为是单节点模式，所以文件副本设置1。这是Hadoop的容错机制，类似于硬盘阵列</li>
</ul>
</blockquote>
<p>然后还需要设置一下免密码登陆<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t dsa -P <span class="string">''</span> <span class="operator">-f</span> ~/.ssh/id_dsa</span><br><span class="line">cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>最后格式化一下文件系统， 就可以启动了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文档">参考文档</h3><p>[1] <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="external">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>Hadoop2.6</code> 是目前Hadoop的最新版本，从下面链接获得</p>
<blockquote>
<p><a href="http://hadoop.apache.org/releases.html#Download" target="_blan]]>
    </summary>
    
      <category term="hadoop" scheme="http://valux.cn/tags/hadoop/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="bigdata" scheme="http://valux.cn/categories/essay/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gVIM 简洁配置 in Windows]]></title>
    <link href="http://valux.cn/2015/04/13/e6b5e02e8a7914f3/"/>
    <id>http://valux.cn/2015/04/13/e6b5e02e8a7914f3/</id>
    <published>2015-04-12T16:04:31.000Z</published>
    <updated>2015-07-31T19:50:36.436Z</updated>
    <content type="html"><![CDATA[<h3 id="Vundle">Vundle</h3><p>捣鼓了一段时间的VIM，神器终归是神器，果然编码效率提升了许多，当然还需要很多插件来配合。自己装插件很麻烦，还要有Vundle这个插件管理器</p>
<blockquote>
<p>Vundle -  <a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="external">https://github.com/gmarik/Vundle.vim</a></p>
</blockquote>
<p>下载下来放在copy 到 vimfiles 下面，然后编辑 _vimrc (windows 环境)，还是先放图</p>
<p><img src="/img/20150413184529343.png" alt="vim"></p>
<h3 id="配置">配置</h3><p>然后在_vimrc文件后面添加如下必须的脚本(windows环境)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> rtp+=~/vimfiles/bundle/Vundle.vim/</span><br><span class="line"><span class="built_in">let</span> path=’~/vimfiles/bundle’</span><br><span class="line">call vundle<span class="comment">#begin(path)</span></span><br><span class="line">Plugin ‘gmarik/Vundle.vim’</span><br><span class="line">”  *插入需要加载的插件</span><br><span class="line">call vundle<span class="comment">#end()</span></span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>
<p>其它需要的插件只要用</p>
<blockquote>
<p>Plugin ‘插件名’ </p>
</blockquote>
<p>添加就行，支持vim-scripts, git repo 和git full path，Vundle会去自动下载，多个开发环境之间只需要复制一份_vimrc文件就行</p>
<p>我用的插件及配置如下(直接替换上面*号那行)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Plugin ‘vim-scripts/The-NERD-Tree’</span><br><span class="line"> ”  NERD文件系统插件，就是左边那个文件列表</span><br><span class="line"><span class="built_in">let</span> g:nerdtree_tabs_open_on_new_tab=<span class="number">1</span></span><br><span class="line">” 保证在每个新开的tab里 NERD是默认打开的</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">” 绑定F2到 开/关 NERD</span><br><span class="line">Plugin ‘vim-scripts/tagbar’</span><br><span class="line">” tagbar就是右边列表，列出了程序里的变量、方法等，可以进行跳转。 tagbar感觉比taglist好用</span><br><span class="line">” 需要安装ctags</span><br><span class="line">map &lt;silent&gt;&lt;F3&gt; :TagbarToggle&lt;CR&gt;</span><br><span class="line">” 绑定F3到 开/关 Tagbar</span><br><span class="line">Plugin ‘bling/vim-airline’</span><br><span class="line">” 注意截图顶上和下面彩色状态条，就是这个炫酷的插件</span><br><span class="line"><span class="built_in">let</span> g:airline<span class="comment">#extensions#tabline#enabled = 1</span></span><br><span class="line">” 开启顶部buffer列表，打开的所有buffer会列出来</span><br><span class="line"><span class="built_in">set</span> laststatus=<span class="number">2</span></span><br><span class="line">” 始终显示下面的状态条</span><br><span class="line">Plugin ‘altercation/vim-colors-solarized’</span><br><span class="line">” 这个是一个比较有名的配色方案</span><br><span class="line">Plugin ‘vim-scripts/ctrlp.vim’</span><br><span class="line">” 这个是最下面的文件查找工具，类似于 Resharper的 Alt+N  或者 Pycharm 的 双击 Shift</span><br><span class="line">Plugin ‘vim-scripts/bufexplorer.zip’</span><br><span class="line">” buffer 管理工具，其实感觉不太好用，但是还没找到更好的</span><br><span class="line">Plugin ‘klen/python-mode’</span><br><span class="line">” 这个是python的集成工具，功能强大</span><br><span class="line"><span class="built_in">let</span> g:pymode_options_colorcolumn = <span class="number">0</span></span><br><span class="line">” windows环境下 会在textwidth的地方显示一个红色的竖条，比较碍眼，所以关了</span><br><span class="line"><span class="built_in">let</span> g:pymode_folding = <span class="number">0</span></span><br><span class="line">” 默认会折叠所有的<span class="keyword">function</span>， 阅读代码感觉不太方便，所以也关了</span><br></pre></td></tr></table></figure>
<p>设置好后打开一个vim实例，输入<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PluginInstall&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>就会自动安装配置的所有插件，然后重启Vim就OK了</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Vundle">Vundle</h3><p>捣鼓了一段时间的VIM，神器终归是神器，果然编码效率提升了许多，当然还需要很多插件来配合。自己装插件很麻烦，还要有Vundle这个插件管理器</p>
<blockquote>
<p>Vundle -  <a href="]]>
    </summary>
    
      <category term="vim" scheme="http://valux.cn/tags/vim/"/>
    
      <category term="essay" scheme="http://valux.cn/categories/essay/"/>
    
      <category term="ide" scheme="http://valux.cn/categories/essay/ide/"/>
    
  </entry>
  
</feed>