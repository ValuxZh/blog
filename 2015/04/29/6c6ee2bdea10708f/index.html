<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>探究Spark的shuffle实现 | VALUX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文链接：http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/    作者：Jerry ShaoBackground在MapReduce框架中，shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了">
<meta property="og:type" content="article">
<meta property="og:title" content="探究Spark的shuffle实现">
<meta property="og:url" content="http://valux.cn/2015/04/29/6c6ee2bdea10708f/index.html">
<meta property="og:site_name" content="VALUX">
<meta property="og:description" content="原文链接：http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/    作者：Jerry ShaoBackground在MapReduce框架中，shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了">
<meta property="og:image" content="http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-process.jpg">
<meta property="og:image" content="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle.png">
<meta property="og:image" content="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle-consolidate.png">
<meta property="og:image" content="http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-shuffle.png">
<meta property="og:updated_time" content="2015-07-31T19:50:19.052Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="探究Spark的shuffle实现">
<meta name="twitter:description" content="原文链接：http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/    作者：Jerry ShaoBackground在MapReduce框架中，shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了">
  
    <link rel="alternative" href="/atom.xml" title="VALUX" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="/js/jquery-2.1.4.min.js" type="text/javascript"></script>
  
  
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?6a7982ffd64704578c67a74f393d757a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-65362177-1', 'auto');
  ga('send', 'pageview');

</script>
  

</head>
<body style="background-color: #FFF">
  <img class="bg-image" src="/img/background.jpg">
  <header id="header" class="clearfix header-fixed-top">
  <div class="nav">
    <h1>
      <a href="http://valux.cn" style="color:#FFF; text-shadow: 0 1px 0 #ccc, 0 2px 0 #c9c9c9, 0 3px 0 #bbb, 0 4px 0 #b9b9b9, 0 5px 0 #aaa, 0 6px 1px rgba(0,0,0,0.1), 0 0 5px rgba(0,0,0,0.1),0 1px 3px rgba(0,0,0,0.3),0 3px 5px rgba(0,0,0,0.2),0 5px 10px rgba(0,0,0,0.25);">VALUX</a>
    </h1>
    <ul>
        
         <li>
          <a class="main-nav-link" href="/">主页</a>
          </li>
        
         <li>
          <a class="main-nav-link" href="/archives">归档</a>
          </li>
        
         <li>
          <a class="main-nav-link" href="/tags">标签</a>
          </li>
        
         <li>
          <a class="main-nav-link" href="/about">关于</a>
          </li>
        
    </ul>
  </div>
</header>

  <div id="container">
  
    <div id="article-anchor" class="article-anchor">
    <p>
        <b id="article-anchor-content-toggle" title="收起" style="cursor:pointer;">目录[-]</b>
    </p>
    <div class="article-anchor-content" id="article-anchor-content"> </div>
</div>


<script>
	$(document).ready(function(){
		var title = $("#article-title").text().trim();

		$("#article-anchor-content").append('<li><a class="article-anchor-title anchor-link" onclick="return false;" href="#" link="#article-title">'
			+title +'</a></li>');
		

		$(".article-inner").find("h2,h3,h4,h5,h6").each(function(i,item){
		    var tag = $(item).get(0).localName;
		    $(item).attr("id","anchor-h"+i);
		    $("#article-anchor-content").append('<li><a class="article-anchor-'+tag+' anchor-link" onclick="return false;" href="#" link="#anchor-h'+i+'">'
		    	+$(this).text().trim()+'</a></li>');		    
		});

		$(".article-anchor-h2").css("margin-left",0);
		$(".article-anchor-h3").css("margin-left",10);
		$(".article-anchor-h4").css("margin-left",20);
		$(".article-anchor-h5").css("margin-left",30);
		$(".article-anchor-h6").css("margin-left",40);

		$("#article-anchor-content-toggle").click(function(){
		    var text = $(this).html();
		    if(text=="目录[-]"){
		        $(this).html("目录[+]");
		        $(this).attr({"title":"展开"});
		    }else{
		        $(this).html("目录[-]");
		        $(this).attr({"title":"收起"});
		    }
		    $("#article-anchor-content").toggle();
		});

		$(".anchor-link").click(function(){
			$("html,body").animate({scrollTop: $($(this).attr("link")).offset().top - 50}, 1000);
		});

	});
</script>
  
  <div id="main" class="clearfix">
    <div class="content clearfix">      
      <article id="post-探究Spark的shuffle实现" class="article article-type-post" itemscope itemprop="blogPost">
        <h2 class="title">
          <a id="article-title" href="">探究Spark的shuffle实现</a>
        </h2>
        <div class="tag-list">
          
          <span class="article-meta">
            <a href="/2015/04/29/6c6ee2bdea10708f/" class="article-date">
  	<time datetime="2015-04-28T19:50:10.000Z" itemprop="datePublished">2015-04-29</time>
</a>
          </span>
          
          
	<span class="article-tag">
		标签: &nbsp;
		<a class="article-tag-link" href="/tags/shuffle/">shuffle</a><a class="article-tag-link" href="/tags/spark/">spark</a>
	</span>
         
        </div>                    
            <div class="article-inner">
              
                <input type="hidden" class="isFancy" />
                

                          <div class="article-entry" itemprop="articleBody">
                            
                                  <p>原文链接：<a href="http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/" target="_blank">http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/</a>    作者：Jerry Shao<a href="http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/" target="_blank"></a></p><h3 id="background" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 24.5px;">Background</h3><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在MapReduce框架中，shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了整个程序的性能和吞吐量。Spark作为MapReduce框架的一种实现，自然也实现了shuffle的逻辑，本文就深入研究Spark的shuffle是如何实现的，有什么优缺点，与Hadoop MapReduce的shuffle有什么不同。</p><h2 id="shuffle" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 31.5px;">Shuffle</h2><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">Shuffle是MapReduce框架中的一个特定的phase，介于Map phase和Reduce phase之间，当Map的输出结果要被Reduce使用时，输出结果需要按key哈希，并且分发到每一个Reducer上去，这个过程就是shuffle。由于shuffle涉及到了磁盘的读写和网络的传输，因此shuffle性能的高低直接影响到了整个程序的运行效率。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">下面这幅图清晰地描述了MapReduce算法的整个流程，其中shuffle phase是介于Map phase和Reduce phase之间。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="mapreduce running process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-process.jpg" width="640" style="max-width: 100%; height: auto;"></p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">概念上shuffle就是一个沟通数据连接的桥梁，那么实际上shuffle这一部分是如何实现的的呢，下面我们就以Spark为例讲一下shuffle在Spark中的实现。</p><h2 id="spark_shuffle" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 31.5px;">Spark Shuffle进化史</h2><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">先以图为例简单描述一下Spark中shuffle的整一个流程：</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="spark shuffle process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle.png" width="640" style="max-width: 100%; height: auto;"></p><ul style="padding: 0px; margin-right: 0px; margin-left: 25px; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><li>首先每一个Mapper会根据Reducer的数量创建出相应的bucket，bucket的数量是<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-1-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-1" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.753em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.098em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-3" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">M<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span><span class="mo" id="MathJax-Span-4" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Main;">×</span><span class="mi" id="MathJax-Span-5" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>，其中<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-2-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-6" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 1.313em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 1.074em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-7" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-8" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">M<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 0.932em;"></span></span></nobr></span>是Map的个数，<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-3-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-9" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.955em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.777em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-10" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-11" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>是Reduce的个数。</li><li>其次Mapper产生的结果会根据设置的partition算法填充到每个bucket中去。这里的partition算法是可以自定义的，当然默认的算法是根据key哈希到不同的bucket中去。</li><li>当Reducer启动时，它会根据自己task的id和所依赖的Mapper的id从远端或是本地的block manager中取得相应的bucket作为Reducer的输入进行处理。</li></ul><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">这里的bucket是一个抽象概念，在实现中每个bucket可以对应一个文件，可以对应文件的一部分或是其他等。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">接下来我们分别从<strong>shuffle write</strong>和<strong>shuffle fetch</strong>这两块来讲述一下Spark的shuffle进化史。</p><h3 id="shuffle_write" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 24.5px;">Shuffle Write</h3><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在Spark 0.6和0.7的版本中，对于shuffle数据的存储是以文件的方式存储在block manager中，与<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">rdd.persist(StorageLevel.DISk<em>ONLY)</em></code>采取相同的策略，可以参看：<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(</span>attemptId: <span class="type">Long</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">blockManager</span> =</span> <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line">  <span class="keyword">var</span> shuffle: <span class="type">ShuffleBlocks</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> buckets: <span class="type">ShuffleWriterGroup</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Obtain all the block writers for shuffle blocks.</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">ser</span> =</span> <span class="type">SparkEnv</span>.get.serializerManager.get(dep.serializerClass)</span><br><span class="line">    shuffle = blockManager.shuffleBlockManager.forShuffle(dep.shuffleId, numOutputSplits, ser)</span><br><span class="line">    buckets = shuffle.acquireWriters(partition)</span><br><span class="line">    <span class="comment">// Write the map output to its associated buckets.</span></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- rdd.iterator(split, taskContext)) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">pair</span> =</span> elem.asInstanceOf[<span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">bucketId</span> =</span> dep.partitioner.getPartition(pair._1)</span><br><span class="line">      buckets.writers(bucketId).write(pair)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commit the writes. Get the size of each bucket block (total block size).</span></span><br><span class="line">    <span class="keyword">var</span> totalBytes = <span class="number">0</span>L</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">compressedSizes</span>:</span> <span class="type">Array</span>[<span class="type">Byte</span>] = buckets.writers.map &#123; writer:   <span class="type">BlockObjectWriter</span> =&gt;</span><br><span class="line">      writer.commit()</span><br><span class="line">      writer.close()</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">size</span> =</span> writer.size()</span><br><span class="line">      totalBytes += size</span><br><span class="line">      <span class="type">MapOutputTracker</span>.compressSize(size)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">    <span class="comment">// If there is an exception from running the task, revert the partial writes</span></span><br><span class="line">    <span class="comment">// and throw the exception upstream to Spark.</span></span><br><span class="line">    <span class="keyword">if</span> (buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      buckets.writers.foreach(_.revertPartialWrites())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Release the writers back to the shuffle block manager.</span></span><br><span class="line">    <span class="keyword">if</span> (shuffle != <span class="literal">null</span> &amp;&amp; buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      shuffle.releaseWriters(buckets)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Execute the callbacks on task completion.</span></span><br><span class="line">    taskContext.executeOnCompleteCallbacks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>我已经将一些干扰代码删去。可以看到Spark在每一个Mapper中为每个Reducer创建一个bucket，并将RDD计算结果放进bucket中。需要注意的是每个bucket是一个<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ArrayBuffer</code>，也就是说Map的输出结果是会先存储在内存。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">接着Spark会将ArrayBuffer中的Map输出结果写入block manager所管理的磁盘中，这里文件的命名方式为：<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">shuffle + shuffle<em>id + “</em>“ + map partition id + “_” + shuffle partition id</code>。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">早期的shuffle write有两个比较大的问题：</p><ol style="padding: 0px; margin-right: 0px; margin-left: 25px; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><li>Map的输出必须先全部存储到内存中，然后写入磁盘。这对内存是一个非常大的开销，当内存不足以存储所有的Map output时就会出现OOM。</li><li>每一个Mapper都会产生Reducer number个shuffle文件，如果Mapper个数是1k，Reducer个数也是1k，那么就会产生1M个shuffle文件，这对于文件系统是一个非常大的负担。同时在shuffle数据量不大而shuffle文件又非常多的情况下，随机写也会严重降低IO的性能。</li></ol><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在Spark 0.8版本中，shuffle write采用了与RDD block write不同的方式，同时也为shuffle write单独创建了<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>，部分解决了0.6和0.7版本中遇到的问题。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">首先我们来看一下Spark 0.8的具体实现：<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(</span>attemptId: <span class="type">Long</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">blockManager</span> =</span> <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line">  <span class="keyword">var</span> shuffle: <span class="type">ShuffleBlocks</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> buckets: <span class="type">ShuffleWriterGroup</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Obtain all the block writers for shuffle blocks.</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">ser</span> =</span> <span class="type">SparkEnv</span>.get.serializerManager.get(dep.serializerClass)</span><br><span class="line">    shuffle = blockManager.shuffleBlockManager.forShuffle(dep.shuffleId, numOutputSplits, ser)</span><br><span class="line">    buckets = shuffle.acquireWriters(partition)</span><br><span class="line">    <span class="comment">// Write the map output to its associated buckets.</span></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- rdd.iterator(split, taskContext)) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">pair</span> =</span> elem.asInstanceOf[<span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">bucketId</span> =</span> dep.partitioner.getPartition(pair._1)</span><br><span class="line">      buckets.writers(bucketId).write(pair)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commit the writes. Get the size of each bucket block (total block size).</span></span><br><span class="line">    <span class="keyword">var</span> totalBytes = <span class="number">0</span>L</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">compressedSizes</span>:</span> <span class="type">Array</span>[<span class="type">Byte</span>] = buckets.writers.map &#123; writer:   <span class="type">BlockObjectWriter</span> =&gt;</span><br><span class="line">      writer.commit()</span><br><span class="line">      writer.close()</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">size</span> =</span> writer.size()</span><br><span class="line">      totalBytes += size</span><br><span class="line">      <span class="type">MapOutputTracker</span>.compressSize(size)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">    <span class="comment">// If there is an exception from running the task, revert the partial writes</span></span><br><span class="line">    <span class="comment">// and throw the exception upstream to Spark.</span></span><br><span class="line">    <span class="keyword">if</span> (buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      buckets.writers.foreach(_.revertPartialWrites())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Release the writers back to the shuffle block manager.</span></span><br><span class="line">    <span class="keyword">if</span> (shuffle != <span class="literal">null</span> &amp;&amp; buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">      shuffle.releaseWriters(buckets)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Execute the callbacks on task completion.</span></span><br><span class="line">    taskContext.executeOnCompleteCallbacks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在这个版本中为shuffle write添加了一个新的类<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>，由<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>来分配和管理bucket。同时<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>为每一个bucket分配一个<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">DiskObjectWriter</code>，每个write handler拥有默认100KB的缓存，使用这个write handler将Map output写入文件中。可以看到现在的写入方式变为<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">buckets.writers(bucketId).write(pair)</code>，也就是说Map output的key-value pair是逐个写入到磁盘而不是预先把所有数据存储在内存中在整体flush到磁盘中去。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>的代码如下所示：<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShuffleBlockManager</span>(</span>blockManager: <span class="type">BlockManager</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forShuffle</span>(</span>shuffleId: <span class="type">Int</span>, numBuckets: <span class="type">Int</span>, serializer: <span class="type">Serializer</span>): <span class="type">ShuffleBlocks</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ShuffleBlocks</span> &#123;</span><br><span class="line">      <span class="comment">// Get a group of writers for a map task.</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">acquireWriters</span>(</span>mapId: <span class="type">Int</span>): <span class="type">ShuffleWriterGroup</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">val</span> <span class="title">bufferSize</span> =</span> <span class="type">System</span>.getProperty(<span class="string">"spark.shuffle.file.buffer.kb"</span>, <span class="string">"100"</span>).toInt * <span class="number">1024</span></span><br><span class="line">        <span class="function"><span class="keyword">val</span> <span class="title">writers</span> =</span> <span class="type">Array</span>.tabulate[<span class="type">BlockObjectWriter</span>](numBuckets) &#123; bucketId =&gt;</span><br><span class="line">          <span class="function"><span class="keyword">val</span> <span class="title">blockId</span> =</span> <span class="type">ShuffleBlockManager</span>.blockId(shuffleId, bucketId, mapId)</span><br><span class="line">          blockManager.getDiskBlockWriter(blockId, serializer, bufferSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ShuffleWriterGroup</span>(mapId, writers)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">releaseWriters</span>(</span>group: <span class="type">ShuffleWriterGroup</span>) = &#123;</span><br><span class="line">        <span class="comment">// Nothing really to release here.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>Spark 0.8显著减少了shuffle的内存压力，现在Map output不需要先全部存储在内存中，再flush到硬盘，而是record-by-record写入到磁盘中。同时对于shuffle文件的管理也独立出新的<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">ShuffleBlockManager</code>进行管理，而不是与rdd cache文件在一起了。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">但是这一版Spark 0.8的shuffle write仍然有两个大的问题没有解决：</p><ul style="padding: 0px; margin-right: 0px; margin-left: 25px; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><li>首先依旧是shuffle文件过多的问题，shuffle文件过多一是会造成文件系统的压力过大，二是会降低IO的吞吐量。</li><li>其次虽然Map output数据不再需要预先在内存中evaluate显著减少了内存压力，但是新引入的<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">DiskObjectWriter</code>所带来的buffer开销也是一个不容小视的内存开销。假定我们有1k个Mapper和1k个Reducer，那么就会有1M个bucket，于此同时就会有1M个write handler，而每一个write handler默认需要100KB内存，那么总共需要100GB的内存。这样的话仅仅是buffer就需要这么多的内存，内存的开销是惊人的。当然实际情况下这1k个Mapper是分时运行的话，所需的内存就只有<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">cores <em> reducer numbers </em> 100KB</code>大小了。但是reducer数量很多的话，这个buffer的内存开销也是蛮厉害的。</li></ul><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">为了解决shuffle文件过多的情况，Spark 0.8.1引入了新的shuffle consolidation，以期显著减少shuffle文件的数量。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">首先我们以图例来介绍一下shuffle consolidation的原理。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="spark shuffle  consolidation process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle-consolidate.png" width="640" style="max-width: 100%; height: auto;"></p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">假定该job有4个Mapper和4个Reducer，有2个core，也就是能并行运行两个task。我们可以算出Spark的shuffle write共需要16个bucket，也就有了16个write handler。在之前的Spark版本中，每一个bucket对应的是一个文件，因此在这里会产生16个shuffle文件。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">而在shuffle consolidation中每一个bucket并非对应一个文件，而是对应文件中的一个segment，同时shuffle consolidation所产生的shuffle文件数量与Spark core的个数也有关系。在上面的图例中，job的4个Mapper分为两批运行，在第一批2个Mapper运行时会申请8个bucket，产生8个shuffle文件；而在第二批Mapper运行时，申请的8个bucket并不会再产生8个新的文件，而是追加写到之前的8个文件后面，这样一共就只有8个shuffle文件，而在文件内部这有16个不同的segment。因此从理论上讲shuffle consolidation所产生的shuffle文件数量为<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-4-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-12" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.396em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 2.801em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.098em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-13" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-14" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">C<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span><span class="mo" id="MathJax-Span-15" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Main;">×</span><span class="mi" id="MathJax-Span-16" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.241em; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>，其中<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-5-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-17" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.955em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.777em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.098em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-18" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-19" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">C<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>是Spark集群的core number，<span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-6-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-20" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.955em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0.777em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.158em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-21" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-22" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">R</span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>是Reducer的个数。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">需要注意的是当 <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-7-Frame" style="display: inline; line-height: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px;"><nobr style="transition: none; -webkit-transition: none; border: 0px; padding: 0px; margin: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; vertical-align: 0px;"><span class="math" id="MathJax-Span-23" role="math" style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.872em;"><span style="transition: none; -webkit-transition: none; display: inline-block; position: relative; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 3.217em; height: 0px; font-size: 16.7999992370605px;"><span style="transition: none; -webkit-transition: none; position: absolute; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; clip: rect(3.098em 1000.003em 4.17em -999.997em); top: -3.985em; left: 0.003em;"><span class="mrow" id="MathJax-Span-24" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px;"><span class="mi" id="MathJax-Span-25" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">M<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span><span class="mo" id="MathJax-Span-26" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.301em; margin: 0px; vertical-align: 0px; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-27" style="transition: none; -webkit-transition: none; display: inline; position: static; border: 0px; padding: 0px 0px 0px 0.301em; margin: 0px; vertical-align: 0px; font-family: MathJax_Math-italic;">C<span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; overflow: hidden; height: 1px; width: 0.063em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border: 0px; padding: 0px; margin: 0px; vertical-align: 0px; width: 0px; height: 3.991em;"></span></span></span><span style="transition: none; -webkit-transition: none; display: inline-block; position: static; border-width: 0px 0px 0px 0.004em; border-left-style: solid; padding: 0px; margin: 0px; vertical-align: -0.068em; overflow: hidden; width: 0px; height: 1.004em;"></span></span></nobr></span>时shuffle consolidation所产生的文件数和之前的实现是一样的。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">Shuffle consolidation显著减少了shuffle文件的数量，解决了之前版本一个比较严重的问题，但是writer handler的buffer开销过大依然没有减少，若要减少writer handler的buffer开销，我们只能减少Reducer的数量，但是这又会引入新的问题，下文将会有详细介绍。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">讲完了shuffle write的进化史，接下来要讲一下shuffle fetch了，同时还要讲一下Spark的aggregator，这一块对于Spark实际应用的性能至关重要。</p><h3 id="shuffle_fetch_and_aggregator" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 24.5px;">Shuffle Fetch and Aggregator</h3><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">Shuffle write写出去的数据要被Reducer使用，就需要shuffle fetcher将所需的数据fetch过来，这里的fetch包括本地和远端，因为shuffle数据有可能一部分是存储在本地的。Spark对shuffle fetcher实现了两套不同的框架：NIO通过socket连接去fetch数据；OIO通过netty server去fetch数据。分别对应的类是<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>和<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">NettyBlockFetcherIterator</code>。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在Spark 0.7和更早的版本中，只支持<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>，而<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>在shuffle数据量比较大的情况下performance始终不是很好，无法充分利用网络带宽，为了解决这个问题，添加了新的shuffle fetcher来试图取得更好的性能。对于早期shuffle性能的评测可以参看<a href="https://groups.google.com/forum/#!msg/shark-users/IHOb2u5HXSk/huTWyosI1n4J" style="color: rgb(0, 136, 204);" target="_blank" rel="external">Spark usergroup</a>。当然现在<code style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: rgb(221, 17, 68); border-radius: 3px; border: 1px solid rgb(225, 225, 232); white-space: nowrap; background-color: rgb(247, 247, 249);">BasicBlockFetcherIterator</code>的性能也已经好了很多，使用的时候可以对这两种实现都进行测试比较。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">接下来说一下aggregator。我们都知道在Hadoop MapReduce的shuffle过程中，shuffle fetch过来的数据会进行merge sort，使得相同key下的不同value按序归并到一起供Reducer使用，这个过程可以参看下图：</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;"><img alt="mapreduce shuffle process" src="http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-shuffle.png" width="640" style="max-width: 100%; height: auto;"></p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">所有的merge sort都是在磁盘上进行的，有效地控制了内存的使用，但是代价是更多的磁盘IO。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">那么Spark是否也有merge sort呢，还是以别的方式实现，下面我们就细细说明。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">首先虽然Spark属于MapReduce体系，但是对传统的MapReduce算法进行了一定的改变。Spark假定在大多数用户的case中，shuffle数据的sort不是必须的，比如word count，强制地进行排序只会使性能变差，因此Spark并不在Reducer端做merge sort。既然没有merge sort那Spark是如何进行reduce的呢？这就要说到aggregator了。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">aggregator本质上是一个hashmap，它是以map output的key为key，以任意所要combine的类型为value的hashmap。当我们在做word count reduce计算count值的时候，它会将shuffle fetch到的每一个key-value pair更新或是插入到hashmap中(若在hashmap中没有查找到，则插入其中；若查找到则更新value值)。这样就不需要预先把所有的key-value进行merge sort，而是来一个处理一个，省下了外部排序这一步骤。但同时需要注意的是reducer的内存必须足以存放这个partition的所有key和count值，因此对内存有一定的要求。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">在上面word count的例子中，因为value会不断地更新，而不需要将其全部记录在内存中，因此内存的使用还是比较少的。考虑一下如果是group by key这样的操作，Reducer需要得到key对应的所有value。在Hadoop MapReduce中，由于有了merge sort，因此给予Reducer的数据已经是group by key了，而Spark没有这一步，因此需要将key和对应的value全部存放在hashmap中，并将value合并成一个array。可以想象为了能够存放所有数据，用户必须确保每一个partition足够小到内存能够容纳，这对于内存是一个非常严峻的考验。因此Spark文档中建议用户涉及到这类操作的时候尽量增加partition，也就是增加Mapper和Reducer的数量。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">增加Mapper和Reducer的数量固然可以减小partition的大小，使得内存可以容纳这个partition。但是我们在shuffle write中提到，bucket和对应于bucket的write handler是由Mapper和Reducer的数量决定的，task越多，bucket就会增加的更多，由此带来write handler所需的buffer也会更多。在一方面我们为了减少内存的使用采取了增加task数量的策略，另一方面task数量增多又会带来buffer开销更大的问题，因此陷入了内存使用的两难境地。</p><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">为了减少内存的使用，只能将aggregator的操作从内存移到磁盘上进行，Spark社区也意识到了Spark在处理数据规模远远大于内存大小时所带来的问题。因此<a href="https://github.com/apache/incubator-spark/pull/303" style="color: rgb(0, 136, 204);" target="_blank" rel="external">PR303</a>提供了外部排序的实现方案，相信在Spark 0.9 release的时候，这个patch应该能merge进去，到时候内存的使用量可以显著地减少。</p><h2 id="end" style="margin-top: 10px; margin-right: 0px; margin-left: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; line-height: 40px; color: rgb(51, 51, 51); text-rendering: optimizeLegibility; font-size: 31.5px;">End</h2><p style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px;">本文详细地介绍了Spark的shuffle实现是如何进化的，以及遇到问题解决问题的过程。shuffle作为Spark程序中很重要的一个环节，直接影响了Spark程序的性能，现如今的Spark版本虽然shuffle实现还存在着种种问题，但是相比于早期版本，已经有了很大的进步。开源代码就是如此不停地迭代推进，随着Spark的普及程度越来越高，贡献的人越来越多，相信后续的版本会有更大的提升。</p>
                                    
                          </div>
                          
            </div>   
            

            
      </article>

      
        
<nav id="article-nav">
  
  <span id="article-nav-newer">
    <strong class="article-nav-caption">上一篇:</strong>
    <a href="/2015/05/03/35327bdac4ff4337/"  class="article-nav-link-wrap">      
      <span class="article-nav-title">
        
          Django中如何使用django-celery完成异步任务
        
      </span>
    </a>
  </span>
  

  
  <span id="article-nav-older" >
    <strong class="article-nav-caption">下一篇:</strong>
    <a href="/2015/04/23/f3765ddf5d8853f3/" class="article-nav-link-wrap">      
      <span class="article-nav-title">Spark及其应用场景初探</span>      
    </a>
  </span>
  
</nav>

            
    
      
        <!-- UY BEGIN -->
<div id="uyan_frame" style="margin-top:25px;"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1970884"></script>
<!-- UY END -->      
      
    </div>
  
  </div>
  
  <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; VALUX 2015 
        | BLOG <a href="https://hexo.io/" target="_blank" style="color: #bbb;"> Hexo</a>
        | THEMES <a href="https://github.com/SerhoLiu/serholiu.com" target="_blank" style="color: #bbb;"> MiniAkio</a>        
    	</div>
      	<a href="javascript:$('html,body').animate({scrollTop: $('html').offset().top }, 1000);" class="to-top">TOP</a>
    </div>
  </div>
</footer>


</div>


</body>
</html>