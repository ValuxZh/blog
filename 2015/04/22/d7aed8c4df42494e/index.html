<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CLR Inside Out - Large Object Heap Uncovered | VALUX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文链接：https://msdn.microsoft.com/en-us/magazine/cc534993.aspx    作者：Maoni StephensThe CLR garbage collector (GC) divides objects into small and large categories. When an object is large, some attribute">
<meta property="og:type" content="article">
<meta property="og:title" content="CLR Inside Out - Large Object Heap Uncovered">
<meta property="og:url" content="http://valux.cn/2015/04/22/d7aed8c4df42494e/index.html">
<meta property="og:site_name" content="VALUX">
<meta property="og:description" content="原文链接：https://msdn.microsoft.com/en-us/magazine/cc534993.aspx    作者：Maoni StephensThe CLR garbage collector (GC) divides objects into small and large categories. When an object is large, some attribute">
<meta property="og:image" content="https://msdn.microsoft.com/cc534993.fig01_L(en-us).gif">
<meta property="og:image" content="https://msdn.microsoft.com/cc534993.fig02_L(en-us).gif">
<meta property="og:image" content="https://msdn.microsoft.com/cc534993.fig03_L(en-us).gif">
<meta property="og:image" content="https://msdn.microsoft.com/cc534993.fig04_L(en-us).gif">
<meta property="og:image" content="http://i.msdn.microsoft.com/Global/Images/clear.gif">
<meta property="og:image" content="http://i.msdn.microsoft.com/Global/Images/clear.gif">
<meta property="og:updated_time" content="2015-07-31T19:47:21.157Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CLR Inside Out - Large Object Heap Uncovered">
<meta name="twitter:description" content="原文链接：https://msdn.microsoft.com/en-us/magazine/cc534993.aspx    作者：Maoni StephensThe CLR garbage collector (GC) divides objects into small and large categories. When an object is large, some attribute">
  
    <link rel="alternative" href="/atom.xml" title="VALUX" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="/js/jquery-2.1.4.min.js" type="text/javascript"></script>
  
  
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?6a7982ffd64704578c67a74f393d757a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-65362177-1', 'auto');
  ga('send', 'pageview');

</script>
  

</head>
<body style="background-color: #FFF">
  <img class="bg-image" src="/img/background.jpg">
  <header id="header" class="clearfix header-fixed-top">
  <div class="nav">
    <h1>
      <a href="http://valux.cn">VALUX</a>
    </h1>
    <ul>
        
         <li>
          <a class="main-nav-link" href="/">主页</a>
          </li>
        
         <li>
          <a class="main-nav-link" href="/archives">归档</a>
          </li>
        
         <li>
          <a class="main-nav-link" href="/tags">标签</a>
          </li>
        
         <li>
          <a class="main-nav-link" href="/about">关于</a>
          </li>
        
    </ul>
  </div>
</header>

  <div id="container">
  
    <div id="article-anchor" class="article-anchor">
    <p>
        <b id="article-anchor-content-toggle" title="收起" style="cursor:pointer;">目录[-]</b>
    </p>
    <div class="article-anchor-content" id="article-anchor-content"> </div>
</div>


<script>
	$(document).ready(function(){
		var title = $("#article-title").text().trim();

		$("#article-anchor-content").append('<li><a class="article-anchor-title anchor-link" onclick="return false;" href="#" link="#article-title">'
			+title +'</a></li>');
		

		$(".article-inner").find("h2,h3,h4,h5,h6").each(function(i,item){
		    var tag = $(item).get(0).localName;
		    $(item).attr("id","anchor-h"+i);
		    $("#article-anchor-content").append('<li><a class="article-anchor-'+tag+' anchor-link" onclick="return false;" href="#" link="#anchor-h'+i+'">'
		    	+$(this).text().trim()+'</a></li>');		    
		});

		$(".article-anchor-h2").css("margin-left",0);
		$(".article-anchor-h3").css("margin-left",10);
		$(".article-anchor-h4").css("margin-left",20);
		$(".article-anchor-h5").css("margin-left",30);
		$(".article-anchor-h6").css("margin-left",40);

		$("#article-anchor-content-toggle").click(function(){
		    var text = $(this).html();
		    if(text=="目录[-]"){
		        $(this).html("目录[+]");
		        $(this).attr({"title":"展开"});
		    }else{
		        $(this).html("目录[-]");
		        $(this).attr({"title":"收起"});
		    }
		    $("#article-anchor-content").toggle();
		});

		$(".anchor-link").click(function(){
			$("html,body").animate({scrollTop: $($(this).attr("link")).offset().top - 50}, 1000);
		});

	});
</script>
  
  <div id="main" class="clearfix">
    <div class="content clearfix">      
      <article id="post-CLR Inside Out - Large Object Heap Uncovered" class="article article-type-post" itemscope itemprop="blogPost">
        <h2 class="title">
          <a id="article-title" href="">CLR Inside Out - Large Object Heap Uncovered</a>
        </h2>
        <div class="tag-list">
          
          <span class="article-meta">
            <a href="/2015/04/22/d7aed8c4df42494e/" class="article-date">
  	<time datetime="2015-04-21T16:04:31.000Z" itemprop="datePublished">2015-04-22</time>
</a>
          </span>
          
          
	<span class="article-tag">
		标签: &nbsp;
		<a class="article-tag-link" href="/tags/clr/">clr</a><a class="article-tag-link" href="/tags/gc/">gc</a><a class="article-tag-link" href="/tags/heap/">heap</a>
	</span>
         
        </div>                    
            <div class="article-inner">
              
                <input type="hidden" class="isFancy" />
                

                          <div class="article-entry" itemprop="articleBody">
                            
                                  <div id="main" style="border: 0px; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; margin: 0px; outline: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 16.0016002655029px;"><div class="ArticleNormalPara" id="id0070001" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">原文链接：<a href="https://msdn.microsoft.com/en-us/magazine/cc534993.aspx" target="_blank">https://msdn.microsoft.com/en-us/magazine/cc534993.aspx</a>    作者：<strong style="line-height: 16.0016002655029px; border: 0px; margin: 0px; outline: 0px; padding: 0px; color: rgb(38, 37, 42); font-size: 14px;">Maoni Stephens</strong><a href="https://msdn.microsoft.com/en-us/magazine/cc534993.aspx" target="_blank"></a></div><div class="ArticleNormalPara" id="id0070001" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">The CLR garbage collector (GC) divides objects into small and large categories. When an object is large, some attributes associated with it become more significant than if the object is small. For instance, compacting it—copying the memory elsewhere on the heap—is expensive. In this month’s column I am going to look at the large object heap in depth. I will talk about what qualifies an object as a large object, how these large objects are collected, and what kind of performance implications large objects impose.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070002" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">The Large Object Heap and the GC</div><div class="ArticleNormalPara" id="id0070003" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">In the Microsoft<span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; vertical-align: text-top;">®</span> .NET Framework 1.1 and 2.0, if an object is greater than or equal to 85,000 bytes it’s considered a large object. This number was determined as a result of performance tuning. When an object allocation request comes in and meets that size threshold, it will be allocated on the large object heap. What does this mean exactly? To understand this, it may be beneficial to explain some fundamentals about the .NET garbage collector.</div><div class="ArticleNormalPara" id="id0070004" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">As many of you are aware, the .NET garbage collector is a generational collector. It has three generations: generation 0, generation 1, and generation 2. The reason for this is so that in a well-tuned application, you can expect most objects to die in generation 0. For example, in a server app, the allocations associated with each request should die after the request is finished. The in-flight allocation requests will make it into generation 1 and die there. Essentially, generation 1 acts as a buffer between young object areas and long-lived object areas.</div><div class="ArticleNormalPara" id="id0070005" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">From a generation point of view, large objects belong to generation 2 because they are collected only when there is a generation 2 collection. When a generation is collected, all younger generations are also collected. So for example, when a generation 1 garbage collection happens, both generation 1 and 0 are collected. And when a generation 2 garbage collection happens, the whole heap is collected. For this reason, a generation 2 garbage collection is also known as a full garbage collection. In this column I will use the term generation 2 garbage collection instead of full garbage collection, but they are interchangeable.</div><div class="ArticleNormalPara" id="id0070006" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Generations are the logical view of the garbage collector heap. Physically, objects live on managed heap segments. A managed heap segment is a chunk of memory that the garbage collector reserves from the OS (via calling VirtualAlloc) on behalf of managed code. When the CLR is loaded, two initial heap segments are allocated—one for small objects and one for large objects, which I will refer to as the small object heap (SOH) and the large object heap (LOH), respectively.</div><div class="ArticleNormalPara" id="id0070007" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Allocation requests are then satisfied by putting managed objects on one of these managed heap segments. If the object is less than 85,000 bytes, it will be put on a SOH segment; otherwise it’ll be on a LOH segment. Segments are committed (in smaller chunks) as more and more objects are allocated onto them.</div><div class="ArticleNormalPara" id="id0070008" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">For the SOH, objects that survive a garbage collection are promoted to the next generation; so objects that survive a generation 0 collection will be considered generation 1 objects, and so on. Objects that survive the oldest generation, however, will still be considered in the oldest generation. In other words, survivors from generation 2 will be generation 2 objects; and survivors from LOH will be LOH objects (collected with generation 2). User code can only allocate in generation 0 (small objects) or LOH (large objects). Only the garbage collector can “allocate” objects in generation 1 (by promoting survivors from generation 0) and generation 2 (by promoting survivors from generations 1 and 2).</div><div class="ArticleNormalPara" id="id0070009" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">When a garbage collection is triggered, the garbage collector traces through the live objects and compacts them. For LOH, though, because compaction is expensive the CLR team chose to sweep them, making a free list out of dead objects that can be reused later to satisfy large object allocation requests. Adjacent dead objects are made into one free object.</div><div class="ArticleNormalPara" id="id0070010" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">An important thing to keep in mind is that even though today we don’t compact LOH, we might in the future. So if you allocate large objects and want to make sure they don’t move, you should still pin them.</div><div class="ArticleNormalPara" id="id0070011" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Note that the figures shown here are only for illustration purposes. I used very few objects, just to show what happens on the heap. In reality there are many more objects there.</div><div class="ArticleNormalPara" id="id0070012" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Figure 1 illustrates a scenario where I form generation 1 after the first generation 0 GC where Obj1 and Obj3 are dead; and I form generation 2 after the first generation 1 GC where Obj2 and Obj5 are dead.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig01_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 1 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">SOH Allocations and Garbage Collections</strong></div></div><div class="ArticleNormalPara" id="id0070013" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Figure 2 illustrates that after a generation 2 garbage collection in which you saw that Obj1 and Obj2 were dead, I formed one free space out of the memory that used to be occupied by Obj1 and Obj2, which then was used to satisfy the allocation request for Obj4. The space after the last object Obj3 until the end of the segment can still be used to satisfy further allocation requests.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig02_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 2 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">LOH Allocations and Garbage Collections</strong></div></div><div class="ArticleNormalPara" id="id0070014" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">If I don’t have enough free space to accommodate the large object allocation requests, I will first attempt to acquire more segments from the OS. If that fails, then I will trigger a generation 2 garbage collection in hope of freeing up some space.</div><div class="ArticleNormalPara" id="id0070015" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">During a generation 2 garbage collection, I take the opportunity to release segments that have no live objects on them back to the OS (by calling VirtualFree). Memory from the last live object to the end of the segment is decommitted. And the free spaces remain committed though they are reset, meaning the OS doesn’t need to write data in them back to disk. <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 3</strong> illustrates a scenario in which I release a segment back to the OS (segment 2) and decommit more space on the remaining segments. If I need to use the decommitted space at the end of the segment to satisfy new large object allocation requests, I will commit the memory again.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig03_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 3 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Dead Segments Released on LOH during Garbage Collection</strong></div></div><div class="ArticleNormalPara" id="id0070016" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">For an explanation on commit/decommit, please see the MSDN<span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; vertical-align: text-top;">®</span> documentation on VirtualAlloc at<a id="ctl00_MTContentSelector1_mainContentContainer_ctl06" href="http://go.microsoft.com/fwlink/?LinkId=116041" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116041</a>.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070017" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">When a Large Object Gets Collected</div><div class="ArticleNormalPara" id="id0070018" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">To determine when a large object is collected, let’s first talk about when a garbage collection happens in general. A garbage collection occurs if one of the following conditions happens:</div><div class="ArticleNormalPara" id="id0070019" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Allocation Exceeds the Generation 0 or Large Object Threshold Most GCs happen because of allocations on the managed heap (this is the most typical case).</div><div class="ArticleNormalPara" id="id0070020" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">System.GC.Collect Is Called When someone calls GC.Collect on generation 2 (by passing either no arguments to GC.Collect or passing GC.MaxGeneration as an argument), the LOH will get collected right away along with the rest of the managed heap.</div><div class="ArticleNormalPara" id="id0070021" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">System Is in Low Memory Situation This happens when I receive the high memory notification from the OS. If I think doing a generation 2 GC will be productive, I will trigger one.</div><div class="ArticleNormalPara" id="id0070022" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">The threshold is a property of each generation. When you allocate objects into a generation, you increase the amount of memory in that generation and get closer to the generation’s threshold. And when the threshold is exceeded for a generation, a garbage collection is triggered on that generation. So when you allocate small or large objects, you consume generation 0’s and LOH’s respective thresholds. And when the garbage collector allocates into generation 1 and 2, it consumes generation 1 thresholds. These thresholds are dynamically tuned as the program runs.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070023" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">LOH Performance Implications</div><div class="ArticleNormalPara" id="id0070024" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Let’s look at allocation costs. The CLR makes the guarantee that the memory for every new object I give out is cleared. This means the allocation cost of a large object is completely dominated by memory clearing (unless it triggers a garbage collection). If it takes two cycles to clear 1 byte, it means it takes 170,000 cycles to clear the smallest large object. It’s not uncommon for people to allocate large objects that are a bit too large. For a 16MB object on a 2GHz machine, it will take approximately 16ms to clear the memory. That’s a rather large cost.</div><div class="ArticleNormalPara" id="id0070025" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Now let’s see about collection costs. As mentioned earlier, LOH and generation 2 are collected together. If either one’s threshold is exceeded, a generation 2 collection will be triggered. If a generation 2 was triggered because of the LOH, generation 2 itself won’t necessarily get much smaller after the garbage collection. Now, if there’s not much data on generation 2, this is not a problem. But if generation 2 is big, it could cause performance problems if many generation 2 garbage collections are triggered. If many large objects are allocated on a very temporary basis and you have a big SOH, you could be spending too much time running garbage collections; not to mention that the allocation cost can really add up if you keep allocating and letting really large objects go.</div><div class="ArticleNormalPara" id="id0070026" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Very large objects on the LOH are usually arrays (it’s very rare to have an instance object that’s really, really large). If the elements of an array are reference-rich, the cost is high. If the element doesn’t contain any references, I wouldn’t need to go through the array at all. For example, if you use an array to store nodes in a binary tree, one way to implement it is to refer to a node’s right and left node by the actual nodes:</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl07" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></span></p><div class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl07_" style="border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 611.1875px;"><div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl07_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">class Node<br>{<br>    Data d;<br>    Node left;<br>    Node right;<br>};<br><br>Node[] binary<em>tr = new Node [num_nodes];<br></em></pre></div></div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"></p><div class="ArticleNormalPara" id="id0070035" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">If num_nodes is a large number, it means you will need to go through at least two references per element. An alternative approach is to store the index of the right and the left node:</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl08" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></span></p>&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl08“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 611.1875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl08_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">class Node<br>{<br>    Data d;<br>    uint left<em>index;<br>    uint right_index;<br>};<br></em></pre></div></div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"></p><div class="ArticleNormalPara" id="id0070042" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">This way, instead of referring to the left node’s data as left.d, you would refer to it as binary_tr[left_index].d. And the garbage collector wouldn’t need to look at any references for left and right node.</div><div class="ArticleNormalPara" id="id0070043" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Out of the three reasons for a collection, the first two are usually more dominant than the third. Therefore, it’s best if you can allocate a pool of large objects and reuse them instead of allocating temporary ones. Yun Jin has a good example of such a buffer pool in his blog entry (<a id="ctl00_MTContentSelector1_mainContentContainer_ctl09" href="http://go.microsoft.com/fwlink/?LinkId=115870" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=115870</a>). Of course, you would want to make the buffer size larger.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070044" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">Collecting Performance Data for the LOH</div><div class="ArticleNormalPara" id="id0070045" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">There are a few ways to collect performance data that’s relevant to the LOH. But before I explain them, let’s talk about why you would want to do it.</div><div class="ArticleNormalPara" id="id0070046" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Before you start collecting performance data for a specific area, hopefully you have already found evidence that you should be looking at this area or you have exhausted other areas that you know of and didn’t find any problems that could explain a performance problem you are observing.</div><div class="ArticleNormalPara" id="id0070047" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">I would recommend reading a blog entry of mine for more explanation (see <a id="ctl00_MTContentSelector1_mainContentContainer_ctl10" href="http://go.microsoft.com/fwlink/?LinkId=116467" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116467</a>). There I talk about the fundamentals of memory and CPU. Additionally, the November 2006 installment of CLR Inside Out on investigating memory issues talks about steps involved in diagnosing performance problems in a managed process that may be related to managed heap (see<a id="ctl00_MTContentSelector1_mainContentContainer_ctl11" href="http://msdn2.microsoft.com/magazine/cc163528" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">msdn2.microsoft.com/magazine/cc163528</a>).</div><div class="ArticleNormalPara" id="id0070048" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">.NET CLR Memory Performance counters are usually a good first step in investigating performance issues. The counters that are relevant to the LOH are the number of generation 2 collections and the large object heap size. The number of generation 2 collections displays the number of times generation 2 garbage collections have occurred since the process started. The counter is incremented at the end of a generation 2 garbage collection (also called a full garbage collection). This counter displays the last observed value.</div><div class="ArticleNormalPara" id="id0070049" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Large object heap size is the current size in bytes, including the free space, of the Large Object Heap. This counter is updated at the end of a garbage collection, not at each allocation.</div><div class="ArticleNormalPara" id="id0070050" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">A common way to look at performance counters is via Perfor­mance Monitor (PerfMon.exe). Use “Add Counters” to add the interesting counter for processes that you care about, as you can see in <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 4</strong>.</div><div style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><img alt="" src="https://msdn.microsoft.com/cc534993.fig04_L(en-us).gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></p><div class="ArticleImageCaptionText" style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 7px 0px 10px; color: rgb(38, 37, 42); font-size: 14px;">Figure 4 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Adding Counters in Performance Monitor</strong></div></div><div class="ArticleNormalPara" id="id0070051" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">You can save the performance counter data to a log file in Perf­Mon. Performance counters can also be queried programmatically. Many people collect them this way as part of their routine testing process. When you spot counters with values that are out of the ordinary, you can then use other means to get more details to help with the investigation.</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><br></p><div class="ArticleTypeTitle" id="id0070052" style="border: 0px; font-weight: bold; font-family: inherit; margin: 3px 0px 0px; outline: 0px; padding: 0px 0px 7px; color: rgb(38, 8, 89); font-size: 16px;">Using a Debugger</div><div class="ArticleNormalPara" id="id0070053" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Before I begin, you should note that the debugging commands I’ll mention in this section are applicable to the Windows<span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; vertical-align: text-top;">®</span> Debuggers. If you need to look at which objects are actually on the LOH, you can use the SoS debugger extension provided by the CLR, which is explained in the November 2006 installment I mentioned previously. An example output of analyzing the LOH is shown in <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 5</strong>.</div><div class="ArticleNormalPara" id="id0070054" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">The bold sections of <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 5</strong> say that the LOH heap size is (16,754,224 + 16,699,288 + 16,284,504 =) 49,738,016 bytes. And between address 023e1000 and 033db630, there are 8,008,736 bytes occupied by Sys­tem.Ob­ject[] objects; 6,663,696 occupied by System.Byte[] objects; and 2,081,792 occupied by free space.</div><div class="figmargin" id="id016" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><div class="MTPS_CollapsibleRegion" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><div class="CollapseRegionLink" style="border: 0px; font-weight: bold; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; cursor: pointer; color: rgb(0, 0, 0);"><img class="LibC_o" src="http://i.msdn.microsoft.com/Global/Images/clear.gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; width: 16px; height: 16px; background: url(https://msdn.microsoft.com/global/Images/LibC.gif) 0px 0px;">  Figure 5 LOH Output</div><div class="MTPS_CollapsibleSection" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 0px 10px; clear: both;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl28_ctl00_ctl00" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl28_ctl00_ctl00“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 601.296875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl28_ctl00_ctl00_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">0:003&gt; .loadby sos mscorwks﻿<br>0:003&gt; !eeheap -gc<br>Number of GC Heaps: 1<br>generation 0 starts at 0x013e35ec<br>generation 1 starts at 0x013e1b6c<br>generation 2 starts at 0x013e1000<br>ephemeral segment allocation context: none<br> segment    begin allocated     size<br>0018f2d0 790d5588  790f4b38 0x0001f5b0(128432)<br>013e0000 013e1000  013e35f8 0x000025f8(9720)<strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><br>Large object heap starts at 0x023e1000<br> segment    begin allocated     size<br>023e0000 023e1000  033db630 0x00ffa630(16754224)<br>033e0000 033e1000  043cdf98 0x00fecf98(16699288)<br>043e0000 043e1000  05368b58 0x00f87b58(16284504)</strong><br>Total Size  0x2f90cc8(49876168)<br>———————————————<br>GC Heap Size  0x2f90cc8(49876168)<br><strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">0:003&gt; !dumpheap -stat 023e1000  033db630<br>total 133 objects<br>Statistics:<br>      MT    Count    TotalSize Class Name<br>001521d0       66      2081792      Free<br>7912273c       63      6663696 System.Byte[]<br>7912254c        4      8008736 System.Object[]<br>Total 133 objects</strong></pre></div></span></div></div></span></div><div class="ArticleNormalPara" id="id0070055" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Sometimes you’ll see that the total size of the LOH is less than 85,000 bytes. Why is this? It’s because the runtime itself actually uses LOH to allocate some objects that are smaller than a large object.</div><div class="ArticleNormalPara" id="id0070056" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Since the LOH is not compacted, sometimes people suspect that the LOH is a source of fragmentation. You really need to first clarify what fragmentation means. There’s fragmentation of the managed heap, which is indicated by the amount of free space between managed objects (in other words, what you see when you do !dumpheap –type Free in SoS); there’s also fragmentation of the virtual memory (VM) address space, which is the memory marked as <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">MEM<em>FREE</em></strong> and which you can see by using various debugger commands in windbg (see <a id="ctl00_MTContentSelector1_mainContentContainer_ctl15" href="http://go.microsoft.com/fwlink/?LinkId=116470" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116470</a>). <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Figure 6</strong> shows the fragmentation in the virtual memory space (note the bold text in the figure).</div><div class="figmargin" id="id018" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><span style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"><div class="MTPS_CollapsibleRegion" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 5px 0px; outline: 0px; padding: 0px;"><div class="CollapseRegionLink" style="border: 0px; font-weight: bold; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; cursor: pointer; color: rgb(0, 0, 0);"><img class="LibC_o" src="http://i.msdn.microsoft.com/Global/Images/clear.gif" style="border-style: none; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; width: 16px; height: 16px; background: url(https://msdn.microsoft.com/global/Images/LibC.gif) 0px 0px;">  Figure 6 VM Space Fragmentation</div><div class="MTPS_CollapsibleSection" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 0px 10px; clear: both;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl30_ctl00_ctl00" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl30_ctl00_ctl00“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 601.296875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl30_ctl00_ctl00_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">0:000&gt; !address﻿<br>    00000000 : 00000000 - 00010000<br>                    Type     00000000<br>                    Protect  00000001 PAGE<em>NOACCESS<br>                    State    00010000 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">MEM_FREE</strong><br>                    Usage    RegionUsageFree<br>    00010000 : 00010000 - 00002000<br>                    Type     00020000 MEM_PRIVATE<br>                    Protect  00000004 PAGE_READWRITE<br>                    State    00001000 MEM_COMMIT<br>                    Usage    RegionUsageEnvironmentBlock<br>    00012000 : 00012000 - 0000e000<br>                    Type     00000000<br>                    Protect  00000001 PAGE_NOACCESS<br>                    State    00010000 <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">MEM_FREE</strong><br>                    Usage    RegionUsageFree<br>… [omitted]<br>—————————— Usage SUMMARY —————————————<br>    TotSize (      KB)   Pct(Tots) Pct(Busy)   Usage<br>     701000 (    7172) : 00.34%    20.69%    : RegionUsageIsVAD<br><strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">   7de15000 ( 2062420) : 98.35%    00.00%    : RegionUsageFree</strong><br>    1452000 (   20808) : 00.99%    60.02%    : RegionUsageImage<br>     300000 (    3072) : 00.15%    08.86%    : RegionUsageStack<br>       3000 (      12) : 00.00%    00.03%    : RegionUsageTeb<br>     381000 (    3588) : 00.17%    10.35%    : RegionUsageHeap<br>          0 (       0) : 00.00%    00.00%    : RegionUsagePageHeap<br>       1000 (       4) : 00.00%    00.01%    : RegionUsagePeb<br>       1000 (       4) : 00.00%    00.01%    : RegionUsageProcessParametrs<br>       2000 (       8) : 00.00%    00.02%    : RegionUsageEnvironmentBlock<br>       Tot: 7fff0000 (2097088 KB) Busy: 021db000 (34668 KB)<br><br>—————————— Type SUMMARY —————————————<br>    TotSize (      KB)   Pct(Tots)  Usage<br>   <strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">7de15000 ( 2062420) : 98.35%   : <free></free></strong><br>    1452000 (   20808) : 00.99%   : MEM_IMAGE<br>     69f000 (    6780) : 00.32%   : MEM_MAPPED<br>     6ea000 (    7080) : 00.34%   : MEM_PRIVATE<br><br>—————————— State SUMMARY —————————————<br>    TotSize (      KB)   Pct(Tots)  Usage<br>    1a58000 (   26976) : 01.29%   : MEM_COMMIT<br>   7de15000 ( 2062420) : 98.35%   : MEM_FREE<br>     783000 (    7692) : 00.37%   : MEM_RESERVE<br><strong style="border: 0px; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;">Largest free region: Base 01432000 - Size 707ee000 (1843128 KB)</strong></em></pre></div></span></div></div></span></div><div class="ArticleNormalPara" id="id0070057" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">As mentioned earlier, fragmentation on the managed heap is used for allocation requests. It’s more common to see virtual memory fragmentation caused by temporary large objects that require frequent garbage collection to acquire new managed heap segments from the OS and release empty ones back to the OS.</div><div class="ArticleNormalPara" id="id0070058" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">To verify whether the LOH is causing VM fragmentation, you can set a breakpoint on VirtualAlloc and VirtualFree and see who calls them. For example, if I want to see who tried to allocate VM chunks from the OS that are larger than 8MB, I can set a breakpoint like this:</div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"><span id="ctl00_MTContentSelector1_mainContentContainer_ctl18" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px;"></span></p>&lt;div class=”libCScode” id=”ctl00_MTContentSelector1_mainContentContainer_ctl18“ style=”border-width: 5px 0px 0px; border-top-style: solid; border-top-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 20px; width: 611.1875px;”&gt;<div class="CodeSnippetTitleBar" style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: rgb(170, 170, 170); font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 3px; white-space: nowrap; height: 15px; word-spacing: normal; background-color: rgb(221, 221, 221);"><div class="CodeDisplayLanguage" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; float: left;"></div></div><div dir="ltr" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; background-color: rgb(221, 221, 221);"><pre class="libCScode" id="ctl00_MTContentSelector1_mainContentContainer_ctl18_code" space="preserve" style="border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-color: rgb(200, 205, 222); font-weight: inherit; font-style: inherit; font-family: 'Courier New', Verdana, Arial, Helvetica, sans-serif; outline: 0px; padding: 5px 5px 0px; color: rgb(0, 0, 102); white-space: pre-wrap; overflow: hidden; font-size: 12px; background: rgb(221, 221, 221);">bp kernel32!virtualalloc “j (dwo(@esp+8)&gt;800000) ‘kb’;’g’”</pre></div><p style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin-bottom: 12px; outline: 0px; padding: 0px;"></p><div class="ArticleNormalPara" id="id0070060" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">This breaks into the debugger and shows me the callstack if Virtual­Alloc is called with the allocation size greater than 8MB (0x800000) and doesn’t break into the bugger otherwise.</div><div class="ArticleNormalPara" id="id0070061" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">In CLR 2.0 we added a feature called VM Hoarding that may be applicable if you are in a situation where segments (including those for both the large and small object heaps) are frequently acquired and released. To specify VM Hoarding, you specify a startup flag called STARTUP_HOARD_GC_VM via the hosting API (see <a id="ctl00_MTContentSelector1_mainContentContainer_ctl19" href="http://go.microsoft.com/fwlink/?LinkId=116471" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px; color: rgb(0, 102, 221); cursor: pointer;" target="_blank" rel="external">go.microsoft.com/fwlink/?LinkId=116471</a>). When you specify this, instead of releasing empty segments back to the OS, the memory on these segments is simply decommitted and put on a standby list. The segments on the standby list will be used later to satisfy new segment requests. So next time I need a new segment, I’ll use one from this standby list if I can find one that’s big enough.</div><div class="ArticleNormalPara" id="id0070062" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Note that this isn’t done for the segments that are too large. This feature is also useful for applications that want to hold onto the segments that they’ve already acquired, like some server apps that seek to avoid fragmentation of the VM space as much as they can so that they don’t cause out-of-memory errors. And they can do this since they are usually the dominating apps on the machine. I strongly recommend you carefully test your application when you use this feature and make sure it has a fairly stable memory usage.</div><div class="ArticleNormalPara" id="id0070063" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Large objects are expensive. The allocation cost is high because the CLR needs to clear the memory for a newly allocated large object to satisfy the CLR guarantee that memory for all newly allocated objects is cleared. The LOH is collected with the rest of the heap, so carefully analyze how that impacts your app’s performance. The recommendation is to reuse large objects if possible to avoid fragmentation on the managed heap and the VM space.</div><div class="ArticleNormalPara" id="id0070064" style="border: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; margin: 0px; outline: 0px; padding: 0px 0px 7px;">Finally, as of right now, the LOH is not compacted as a part of collection, but that is an implementation detail that should not be relied on. So to make sure something is not moved by the GC, always pin it. Now take your newfound LOH knowledge and go take control of the heap.</div><div><br></div>
                                    
                          </div>
                          
            </div>   
            

            
      </article>

      
        
<nav id="article-nav">
  
  <span id="article-nav-newer">
    <strong class="article-nav-caption">上一篇:</strong>
    <a href="/2015/04/23/f3765ddf5d8853f3/"  class="article-nav-link-wrap">      
      <span class="article-nav-title">
        
          Spark及其应用场景初探
        
      </span>
    </a>
  </span>
  

  
  <span id="article-nav-older" >
    <strong class="article-nav-caption">下一篇:</strong>
    <a href="/2015/04/20/4c6208c359793ebc/" class="article-nav-link-wrap">      
      <span class="article-nav-title">打造简洁的markdown编辑器</span>      
    </a>
  </span>
  
</nav>

            
    
      
        <!-- UY BEGIN -->
<div id="uyan_frame" style="margin-top:25px;"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1970884"></script>
<!-- UY END -->      
      
    </div>
  
  </div>
  
  <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; VALUX 2015 
        | BLOG <a href="https://hexo.io/" target="_blank" style="color: #bbb;"> Hexo</a>
        | THEMES <a href="https://github.com/SerhoLiu/serholiu.com" target="_blank" style="color: #bbb;"> MiniAkio</a>        
    	</div>
      	<a href="javascript:$('html,body').animate({scrollTop: $('html').offset().top }, 1000);" class="to-top">TOP</a>
    </div>
  </div>
</footer>


</div>


</body>
</html>